
R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2      X1      X2
1   Airuna  Isabel  Airuna  Isabel
2    Chris  Edward   Chris  Edward
3   Edward  Isabel  Edward  Isabel
4    Foram  Isabel   Foram  Isabel
5    Sudha  Airuna  Airuna   Sudha
6    Caleb   Jiten   Caleb   Jiten
7    Sudha   Caleb   Caleb   Sudha
8  Jasmine  Airuna  Airuna Jasmine
9      Tes Jasmine Jasmine     Tes
10   Foram     Tes   Foram     Tes
[1] "(rpns)ncycles= 100 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2            tag tag_counts selfpairs DegreePercentile1
6    Caleb   Jiten    Caleb_Jiten          1         0               0.8
2    Chris  Edward   Chris_Edward          1         0               0.2
10   Foram     Tes      Foram_Tes          1         0               0.8
7    Caleb   Sudha    Caleb_Sudha          1         0               0.8
9  Jasmine     Tes    Jasmine_Tes          1         0               0.8
4    Foram  Isabel   Foram_Isabel          1         0               0.8
8   Airuna Jasmine Airuna_Jasmine          1         0               1.0
3   Edward  Isabel  Edward_Isabel          1         0               0.8
5   Airuna   Sudha   Airuna_Sudha          1         0               1.0
1   Airuna  Isabel  Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
6                0.2               0.1626311
2                0.8               0.1657029
10               0.8               0.5807918
7                0.8               0.6352452
9                0.8               0.6577704
4                1.0               0.7527507
8                0.8               0.8061586
3                1.0               0.8197270
5                0.8               0.8410714
1                1.0               1.0031106
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 100 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 10"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2      X1      X2
1   Edward  Isabel  Edward  Isabel
2      Tes   Caleb   Caleb     Tes
3      Tes  Airuna  Airuna     Tes
4    Foram   Chris   Chris   Foram
5    Jiten  Edward  Edward   Jiten
6   Isabel  Airuna  Airuna  Isabel
7   Isabel  Airuna  Airuna  Isabel
8    Caleb   Sudha   Caleb   Sudha
9  Jasmine   Sudha Jasmine   Sudha
10   Foram Jasmine   Foram Jasmine
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
7 Airuna Isabel Airuna_Isabel          2         0                 1
6 Airuna Isabel Airuna_Isabel          2         0                 1
  DegreePercentile2 DegreePercentileProduct
7                 1               0.9878282
6                 1               1.0156965
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2           tag tag_counts selfpairs DegreePercentile1
4    Chris   Foram   Chris_Foram          1         0               0.2
5   Edward   Jiten  Edward_Jiten          1         0               0.8
9  Jasmine   Sudha Jasmine_Sudha          1         0               0.8
10   Foram Jasmine Foram_Jasmine          1         0               0.8
2    Caleb     Tes     Caleb_Tes          1         0               0.8
8    Caleb   Sudha   Caleb_Sudha          1         0               0.8
1   Edward  Isabel Edward_Isabel          1         0               0.8
3   Airuna     Tes    Airuna_Tes          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
4                0.8               0.1360300
5                0.2               0.1561623
9                0.8               0.6201768
10               0.8               0.6384725
2                0.8               0.6520035
8                0.8               0.6893116
1                1.0               0.7788324
3                0.8               0.8000594
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.785200487953614 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1 Jasmine     Tes Jasmine     Tes
2   Caleb Jasmine   Caleb Jasmine
3   Foram   Chris   Chris   Foram
4  Airuna   Foram  Airuna   Foram
5  Isabel  Edward  Edward  Isabel
6   Sudha   Caleb   Caleb   Sudha
7   Jiten  Airuna  Airuna   Jiten
8   Sudha  Edward  Edward   Sudha
9  Isabel  Isabel  Isabel  Isabel
[1] "(rpns)ncycles= 99 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
9 Isabel Isabel Isabel_Isabel          1         1                 1
  DegreePercentile2 DegreePercentileProduct
9                 1                1.038627
[1] "(rpns)ncycles= 99 ===restpairs===="
      id1     id2           tag tag_counts selfpairs DegreePercentile1
3   Chris   Foram   Chris_Foram          1         0               0.2
7  Airuna   Jiten  Airuna_Jiten          1         0               1.0
1 Jasmine     Tes   Jasmine_Tes          1         0               0.8
6   Caleb   Sudha   Caleb_Sudha          1         0               0.8
8  Edward   Sudha  Edward_Sudha          1         0               0.8
2   Caleb Jasmine Caleb_Jasmine          1         0               0.8
4  Airuna   Foram  Airuna_Foram          1         0               1.0
5  Edward  Isabel Edward_Isabel          1         0               0.8
  DegreePercentile2 DegreePercentileProduct
3               0.8               0.1838833
7               0.2               0.2048106
1               0.8               0.6341540
6               0.8               0.6438692
8               0.8               0.6560478
2               0.8               0.6564599
4               0.8               0.7424167
5               1.0               0.8181793
[1] "================="
[1] "(rpns) ncycles= 99 , degreeProduct.cutoff= 0.765145451883644 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 98 , preserve_rate= 0.1 , length(inpairs[,1])= 8 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1   Foram   Caleb   Caleb   Foram
2   Sudha     Tes   Sudha     Tes
3   Chris   Foram   Chris   Foram
4  Isabel   Sudha  Isabel   Sudha
5   Jiten Jasmine Jasmine   Jiten
6 Jasmine  Edward  Edward Jasmine
7  Airuna   Caleb  Airuna   Caleb
8  Airuna  Isabel  Airuna  Isabel
[1] "(rpns)ncycles= 98 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 98 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
3   Chris   Foram    Chris_Foram          1         0               0.2
5 Jasmine   Jiten  Jasmine_Jiten          1         0               0.8
2   Sudha     Tes      Sudha_Tes          1         0               0.8
6  Edward Jasmine Edward_Jasmine          1         0               0.8
1   Caleb   Foram    Caleb_Foram          1         0               0.8
4  Isabel   Sudha   Isabel_Sudha          1         0               1.0
7  Airuna   Caleb   Airuna_Caleb          1         0               1.0
8  Airuna  Isabel  Airuna_Isabel          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
3               0.8               0.1394490
5               0.2               0.1945810
2               0.8               0.6373258
6               0.8               0.6454941
1               0.8               0.6515282
4               0.8               0.7874867
7               0.8               0.8196271
8               1.0               0.9872249
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 98 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 8"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1  Edward   Caleb   Caleb  Edward
2   Jiten  Airuna  Airuna   Jiten
3     Tes  Edward  Edward     Tes
4  Airuna Jasmine  Airuna Jasmine
5  Airuna   Chris  Airuna   Chris
6  Isabel   Foram   Foram  Isabel
7  Isabel   Caleb   Caleb  Isabel
8     Tes Jasmine Jasmine     Tes
9   Foram  Isabel   Foram  Isabel
10  Sudha   Sudha   Sudha   Sudha
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1    id2          tag tag_counts selfpairs DegreePercentile1
10 Sudha  Sudha  Sudha_Sudha          1         1               0.8
6  Foram Isabel Foram_Isabel          2         0               0.8
9  Foram Isabel Foram_Isabel          2         0               0.8
   DegreePercentile2 DegreePercentileProduct
10               0.8               0.5941563
6                1.0               0.8034194
9                1.0               0.8255250
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
5  Airuna   Chris   Airuna_Chris          1         0               1.0
2  Airuna   Jiten   Airuna_Jiten          1         0               1.0
3  Edward     Tes     Edward_Tes          1         0               0.8
8 Jasmine     Tes    Jasmine_Tes          1         0               0.8
1   Caleb  Edward   Caleb_Edward          1         0               0.8
7   Caleb  Isabel   Caleb_Isabel          1         0               0.8
4  Airuna Jasmine Airuna_Jasmine          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
5               0.2               0.1884718
2               0.2               0.2494370
3               0.8               0.6304786
8               0.8               0.6312042
1               0.8               0.6552146
7               1.0               0.7863202
4               0.8               0.7968704
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.790540269277008 , length(redo.tb[,1])= 3 , length(rest.tb[,1])= 7"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1     X2     X1      X2
1   Sudha Isabel Isabel   Sudha
2     Tes Airuna Airuna     Tes
3  Edward Airuna Airuna  Edward
4   Sudha Edward Edward   Sudha
5 Jasmine  Caleb  Caleb Jasmine
6     Tes  Caleb  Caleb     Tes
7  Isabel  Foram  Foram  Isabel
8   Foram  Jiten  Foram   Jiten
9  Isabel  Chris  Chris  Isabel
[1] "(rpns)ncycles= 99 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1     id2           tag tag_counts selfpairs DegreePercentile1
8  Foram   Jiten   Foram_Jiten          1         0               0.8
9  Chris  Isabel  Chris_Isabel          1         0               0.2
6  Caleb     Tes     Caleb_Tes          1         0               0.8
5  Caleb Jasmine Caleb_Jasmine          1         0               0.8
4 Edward   Sudha  Edward_Sudha          1         0               0.8
1 Isabel   Sudha  Isabel_Sudha          1         0               1.0
3 Airuna  Edward Airuna_Edward          1         0               1.0
7  Foram  Isabel  Foram_Isabel          1         0               0.8
2 Airuna     Tes    Airuna_Tes          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
8               0.2               0.1791230
9               1.0               0.2123002
6               0.8               0.5683334
5               0.8               0.6209871
4               0.8               0.6434971
1               0.8               0.7624377
3               0.8               0.8158781
7               1.0               0.8285466
2               0.8               0.8356457
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 99 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 9"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2      X1      X2
1    Foram  Isabel   Foram  Isabel
2    Caleb     Tes   Caleb     Tes
3    Sudha Jasmine Jasmine   Sudha
4   Airuna     Tes  Airuna     Tes
5  Jasmine  Isabel  Isabel Jasmine
6   Isabel   Caleb   Caleb  Isabel
7    Jiten  Edward  Edward   Jiten
8   Airuna   Foram  Airuna   Foram
9   Edward  Airuna  Airuna  Edward
10   Sudha   Chris   Chris   Sudha
[1] "(rpns)ncycles= 100 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2            tag tag_counts selfpairs DegreePercentile1
7   Edward   Jiten   Edward_Jiten          1         0               0.8
10   Chris   Sudha    Chris_Sudha          1         0               0.2
3  Jasmine   Sudha  Jasmine_Sudha          1         0               0.8
2    Caleb     Tes      Caleb_Tes          1         0               0.8
5   Isabel Jasmine Isabel_Jasmine          1         0               1.0
8   Airuna   Foram   Airuna_Foram          1         0               1.0
6    Caleb  Isabel   Caleb_Isabel          1         0               0.8
9   Airuna  Edward  Airuna_Edward          1         0               1.0
1    Foram  Isabel   Foram_Isabel          1         0               0.8
4   Airuna     Tes     Airuna_Tes          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
7                0.2               0.1648630
10               0.8               0.1879447
3                0.8               0.6486991
2                0.8               0.6687943
5                0.8               0.7721933
8                0.8               0.7808420
6                1.0               0.7850890
9                0.8               0.7950985
1                1.0               0.8011945
4                0.8               0.8031132
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 100 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 10"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1     X2     X1      X2
1    Sudha  Caleb  Caleb   Sudha
2    Foram    Tes  Foram     Tes
3  Jasmine Edward Edward Jasmine
4    Foram  Caleb  Caleb   Foram
5   Isabel Airuna Airuna  Isabel
6   Edward  Jiten Edward   Jiten
7    Sudha Airuna Airuna   Sudha
8   Isabel    Tes Isabel     Tes
9    Chris Airuna Airuna   Chris
10 Jasmine Isabel Isabel Jasmine
[1] "(rpns)ncycles= 100 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
6  Edward   Jiten   Edward_Jiten          1         0               0.8
9  Airuna   Chris   Airuna_Chris          1         0               1.0
2   Foram     Tes      Foram_Tes          1         0               0.8
4   Caleb   Foram    Caleb_Foram          1         0               0.8
3  Edward Jasmine Edward_Jasmine          1         0               0.8
1   Caleb   Sudha    Caleb_Sudha          1         0               0.8
7  Airuna   Sudha   Airuna_Sudha          1         0               1.0
8  Isabel     Tes     Isabel_Tes          1         0               1.0
10 Isabel Jasmine Isabel_Jasmine          1         0               1.0
5  Airuna  Isabel  Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
6                0.2               0.1738300
9                0.2               0.2130975
2                0.8               0.6141203
4                0.8               0.6336384
3                0.8               0.6375623
1                0.8               0.6614381
7                0.8               0.8034711
8                0.8               0.8053278
10               0.8               0.8303911
5                1.0               1.0035142
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 100 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 10"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2     X1      X2
1    Jiten   Caleb  Caleb   Jiten
2      Tes     Tes    Tes     Tes
3    Foram Jasmine  Foram Jasmine
4  Jasmine  Isabel Isabel Jasmine
5    Sudha  Airuna Airuna   Sudha
6    Foram  Airuna Airuna   Foram
7    Sudha  Airuna Airuna   Sudha
8    Caleb   Chris  Caleb   Chris
9   Isabel  Edward Edward  Isabel
10  Edward  Isabel Edward  Isabel
[1] "(rpns)ncycles= 100 ===redopairs===="
      id1    id2           tag tag_counts selfpairs DegreePercentile1
2     Tes    Tes       Tes_Tes          1         1               0.8
9  Edward Isabel Edward_Isabel          2         0               0.8
5  Airuna  Sudha  Airuna_Sudha          2         0               1.0
7  Airuna  Sudha  Airuna_Sudha          2         0               1.0
10 Edward Isabel Edward_Isabel          2         0               0.8
   DegreePercentile2 DegreePercentileProduct
2                0.8               0.6063668
9                1.0               0.7687255
5                0.8               0.7957110
7                0.8               0.8372836
10               1.0               0.8401912
[1] "(rpns)ncycles= 100 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
8  Caleb   Chris    Caleb_Chris          1         0               0.8
1  Caleb   Jiten    Caleb_Jiten          1         0               0.8
3  Foram Jasmine  Foram_Jasmine          1         0               0.8
6 Airuna   Foram   Airuna_Foram          1         0               1.0
4 Isabel Jasmine Isabel_Jasmine          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
8               0.2               0.1707070
1               0.2               0.1904219
3               0.8               0.6364207
6               0.8               0.7962893
4               0.8               0.8029301
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.80027376369908 , length(redo.tb[,1])= 5 , length(rest.tb[,1])= 5"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
      X1      X2     X1      X2
1  Jiten     Tes  Jiten     Tes
2 Edward  Airuna Airuna  Edward
3  Caleb  Isabel  Caleb  Isabel
4  Foram Jasmine  Foram Jasmine
5 Airuna     Tes Airuna     Tes
6  Caleb   Sudha  Caleb   Sudha
7  Chris   Sudha  Chris   Sudha
8 Airuna   Foram Airuna   Foram
9 Isabel  Edward Edward  Isabel
[1] "(rpns)ncycles= 99 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1     id2           tag tag_counts selfpairs DegreePercentile1
7  Chris   Sudha   Chris_Sudha          1         0               0.2
1  Jiten     Tes     Jiten_Tes          1         0               0.2
4  Foram Jasmine Foram_Jasmine          1         0               0.8
6  Caleb   Sudha   Caleb_Sudha          1         0               0.8
5 Airuna     Tes    Airuna_Tes          1         0               1.0
3  Caleb  Isabel  Caleb_Isabel          1         0               0.8
2 Airuna  Edward Airuna_Edward          1         0               1.0
9 Edward  Isabel Edward_Isabel          1         0               0.8
8 Airuna   Foram  Airuna_Foram          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
7               0.8               0.1265708
1               0.8               0.1772824
4               0.8               0.5954554
6               0.8               0.6467400
5               0.8               0.7726950
3               1.0               0.7893919
2               0.8               0.7946466
9               1.0               0.8114442
8               0.8               0.8357444
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 99 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 9"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1  Edward   Foram  Edward   Foram
2   Sudha Jasmine Jasmine   Sudha
3  Airuna   Caleb  Airuna   Caleb
4   Sudha   Jiten   Jiten   Sudha
5  Isabel Jasmine  Isabel Jasmine
6  Airuna  Isabel  Airuna  Isabel
7     Tes     Tes     Tes     Tes
8   Chris  Airuna  Airuna   Chris
9   Foram  Edward  Edward   Foram
10  Caleb  Isabel   Caleb  Isabel
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1   id2          tag tag_counts selfpairs DegreePercentile1
1 Edward Foram Edward_Foram          2         0               0.8
7    Tes   Tes      Tes_Tes          1         1               0.8
9 Edward Foram Edward_Foram          2         0               0.8
  DegreePercentile2 DegreePercentileProduct
1               0.8               0.6470007
7               0.8               0.6516812
9               0.8               0.6592664
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2            tag tag_counts selfpairs DegreePercentile1
4    Jiten   Sudha    Jiten_Sudha          1         0               0.2
8   Airuna   Chris   Airuna_Chris          1         0               1.0
2  Jasmine   Sudha  Jasmine_Sudha          1         0               0.8
5   Isabel Jasmine Isabel_Jasmine          1         0               1.0
3   Airuna   Caleb   Airuna_Caleb          1         0               1.0
10   Caleb  Isabel   Caleb_Isabel          1         0               0.8
6   Airuna  Isabel  Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
4                0.8               0.1506558
8                0.2               0.2205884
2                0.8               0.6590396
5                0.8               0.7713587
3                0.8               0.8025158
10               1.0               0.8090765
6                1.0               1.0349659
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.899432263878835 , length(redo.tb[,1])= 3 , length(rest.tb[,1])= 7"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1  Isabel   Caleb   Caleb  Isabel
2  Edward     Tes  Edward     Tes
3     Tes  Isabel  Isabel     Tes
4   Foram   Sudha   Foram   Sudha
5 Jasmine Jasmine Jasmine Jasmine
6  Edward   Caleb   Caleb  Edward
7   Jiten  Airuna  Airuna   Jiten
8  Airuna   Foram  Airuna   Foram
9   Sudha   Chris   Chris   Sudha
[1] "(rpns)ncycles= 99 ===redopairs===="
      id1     id2             tag tag_counts selfpairs DegreePercentile1
5 Jasmine Jasmine Jasmine_Jasmine          1         1               0.8
  DegreePercentile2 DegreePercentileProduct
5               0.8               0.5988456
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1    id2          tag tag_counts selfpairs DegreePercentile1
9  Chris  Sudha  Chris_Sudha          1         0               0.2
7 Airuna  Jiten Airuna_Jiten          1         0               1.0
2 Edward    Tes   Edward_Tes          1         0               0.8
6  Caleb Edward Caleb_Edward          1         0               0.8
4  Foram  Sudha  Foram_Sudha          1         0               0.8
1  Caleb Isabel Caleb_Isabel          1         0               0.8
3 Isabel    Tes   Isabel_Tes          1         0               1.0
8 Airuna  Foram Airuna_Foram          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
9               0.8               0.1413624
7               0.2               0.1822202
2               0.8               0.6053514
6               0.8               0.6171685
4               0.8               0.6577839
1               1.0               0.8071451
3               0.8               0.8294432
8               0.8               0.8486723
[1] "================="
[1] "(rpns) ncycles= 99 , degreeProduct.cutoff= 0.835211922118649 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 98 , preserve_rate= 0.1 , length(inpairs[,1])= 8 **

[1] "===Before:Aftersort  ===="
      X1      X2      X1      X2
1    Tes Jasmine Jasmine     Tes
2 Isabel   Caleb   Caleb  Isabel
3  Caleb     Tes   Caleb     Tes
4  Sudha  Edward  Edward   Sudha
5  Sudha   Jiten   Jiten   Sudha
6 Edward  Airuna  Airuna  Edward
7 Isabel Jasmine  Isabel Jasmine
8  Foram   Chris   Chris   Foram
[1] "(rpns)ncycles= 98 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 98 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
8   Chris   Foram    Chris_Foram          1         0               0.2
5   Jiten   Sudha    Jiten_Sudha          1         0               0.2
3   Caleb     Tes      Caleb_Tes          1         0               0.8
1 Jasmine     Tes    Jasmine_Tes          1         0               0.8
4  Edward   Sudha   Edward_Sudha          1         0               0.8
6  Airuna  Edward  Airuna_Edward          1         0               1.0
7  Isabel Jasmine Isabel_Jasmine          1         0               1.0
2   Caleb  Isabel   Caleb_Isabel          1         0               0.8
  DegreePercentile2 DegreePercentileProduct
8               0.8               0.1404691
5               0.8               0.1514939
3               0.8               0.6031097
1               0.8               0.6355509
4               0.8               0.6588321
6               0.8               0.7903273
7               0.8               0.8068074
2               1.0               0.8550467
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 98 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 8"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2     X1      X2
1   Airuna   Caleb Airuna   Caleb
2   Airuna  Airuna Airuna  Airuna
3  Jasmine   Foram  Foram Jasmine
4    Foram Jasmine  Foram Jasmine
5    Caleb   Chris  Caleb   Chris
6      Tes   Sudha  Sudha     Tes
7   Isabel     Tes Isabel     Tes
8    Sudha  Edward Edward   Sudha
9    Jiten  Isabel Isabel   Jiten
10  Edward  Isabel Edward  Isabel
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1     id2           tag tag_counts selfpairs DegreePercentile1
3  Foram Jasmine Foram_Jasmine          2         0               0.8
4  Foram Jasmine Foram_Jasmine          2         0               0.8
2 Airuna  Airuna Airuna_Airuna          1         1               1.0
  DegreePercentile2 DegreePercentileProduct
3               0.8               0.6141870
4               0.8               0.6239547
2               1.0               0.9695685
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1    id2           tag tag_counts selfpairs DegreePercentile1
5   Caleb  Chris   Caleb_Chris          1         0               0.8
9  Isabel  Jiten  Isabel_Jiten          1         0               1.0
6   Sudha    Tes     Sudha_Tes          1         0               0.8
8  Edward  Sudha  Edward_Sudha          1         0               0.8
1  Airuna  Caleb  Airuna_Caleb          1         0               1.0
7  Isabel    Tes    Isabel_Tes          1         0               1.0
10 Edward Isabel Edward_Isabel          1         0               0.8
   DegreePercentile2 DegreePercentileProduct
5                0.2               0.1252763
9                0.2               0.1816200
6                0.8               0.6366459
8                0.8               0.6534301
1                0.8               0.7921283
7                0.8               0.8064436
10               1.0               0.8085926
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.80730322890853 , length(redo.tb[,1])= 3 , length(rest.tb[,1])= 7"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1     Tes Jasmine Jasmine     Tes
2     Tes  Isabel  Isabel     Tes
3  Airuna   Jiten  Airuna   Jiten
4  Edward  Airuna  Airuna  Edward
5   Sudha   Sudha   Sudha   Sudha
6 Jasmine   Chris   Chris Jasmine
7   Foram  Isabel   Foram  Isabel
8   Foram   Caleb   Caleb   Foram
9   Caleb  Airuna  Airuna   Caleb
[1] "(rpns)ncycles= 99 ===redopairs===="
    id1   id2         tag tag_counts selfpairs DegreePercentile1
5 Sudha Sudha Sudha_Sudha          1         1               0.8
  DegreePercentile2 DegreePercentileProduct
5               0.8               0.6424031
[1] "(rpns)ncycles= 99 ===restpairs===="
      id1     id2           tag tag_counts selfpairs DegreePercentile1
6   Chris Jasmine Chris_Jasmine          1         0               0.2
3  Airuna   Jiten  Airuna_Jiten          1         0               1.0
1 Jasmine     Tes   Jasmine_Tes          1         0               0.8
8   Caleb   Foram   Caleb_Foram          1         0               0.8
4  Airuna  Edward Airuna_Edward          1         0               1.0
9  Airuna   Caleb  Airuna_Caleb          1         0               1.0
2  Isabel     Tes    Isabel_Tes          1         0               1.0
7   Foram  Isabel  Foram_Isabel          1         0               0.8
  DegreePercentile2 DegreePercentileProduct
6               0.8               0.1630628
3               0.2               0.2027250
1               0.8               0.6338768
8               0.8               0.6381183
4               0.8               0.7766990
9               0.8               0.8072682
2               0.8               0.8102487
7               1.0               0.8140546
[1] "================="
[1] "(rpns) ncycles= 99 , degreeProduct.cutoff= 0.811390476255161 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 98 , preserve_rate= 0.1 , length(inpairs[,1])= 8 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1   Sudha   Sudha   Sudha   Sudha
2 Jasmine   Jiten Jasmine   Jiten
3     Tes  Isabel  Isabel     Tes
4   Caleb   Chris   Caleb   Chris
5  Airuna Jasmine  Airuna Jasmine
6  Airuna  Edward  Airuna  Edward
7     Tes  Airuna  Airuna     Tes
8   Foram   Caleb   Caleb   Foram
[1] "(rpns)ncycles= 98 ===redopairs===="
    id1   id2         tag tag_counts selfpairs DegreePercentile1
1 Sudha Sudha Sudha_Sudha          1         1               0.8
  DegreePercentile2 DegreePercentileProduct
1               0.8               0.6569024
[1] "(rpns)ncycles= 98 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
4   Caleb   Chris    Caleb_Chris          1         0               0.8
2 Jasmine   Jiten  Jasmine_Jiten          1         0               0.8
8   Caleb   Foram    Caleb_Foram          1         0               0.8
3  Isabel     Tes     Isabel_Tes          1         0               1.0
6  Airuna  Edward  Airuna_Edward          1         0               1.0
5  Airuna Jasmine Airuna_Jasmine          1         0               1.0
7  Airuna     Tes     Airuna_Tes          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
4               0.2               0.1387085
2               0.2               0.1526011
8               0.8               0.6248036
3               0.8               0.7875973
6               0.8               0.8148155
5               0.8               0.8167796
7               0.8               0.8335818
[1] "================="
[1] "(rpns) ncycles= 98 , degreeProduct.cutoff= 0.823500455891259 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 7"

** (rpns) Start ncycles= 97 , preserve_rate= 0.1 , length(inpairs[,1])= 7 **

[1] "===Before:Aftersort  ===="
       X1      X2     X1      X2
1  Airuna   Sudha Airuna   Sudha
2   Caleb   Sudha  Caleb   Sudha
3   Caleb  Isabel  Caleb  Isabel
4     Tes   Chris  Chris     Tes
5   Foram Jasmine  Foram Jasmine
6   Jiten  Airuna Airuna   Jiten
7 Jasmine  Edward Edward Jasmine
[1] "(rpns)ncycles= 97 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 97 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
6 Airuna   Jiten   Airuna_Jiten          1         0               1.0
4  Chris     Tes      Chris_Tes          1         0               0.2
7 Edward Jasmine Edward_Jasmine          1         0               0.8
5  Foram Jasmine  Foram_Jasmine          1         0               0.8
2  Caleb   Sudha    Caleb_Sudha          1         0               0.8
1 Airuna   Sudha   Airuna_Sudha          1         0               1.0
3  Caleb  Isabel   Caleb_Isabel          1         0               0.8
  DegreePercentile2 DegreePercentileProduct
6               0.2               0.1900490
4               0.8               0.1935365
7               0.8               0.6225746
5               0.8               0.6386170
2               0.8               0.6565299
1               0.8               0.7468417
3               1.0               0.8018044
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 97 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 7"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1     X2      X1      X2
1    Caleb Edward   Caleb  Edward
2  Jasmine    Tes Jasmine     Tes
3    Foram Isabel   Foram  Isabel
4   Isabel Airuna  Airuna  Isabel
5    Chris  Sudha   Chris   Sudha
6      Tes Airuna  Airuna     Tes
7   Isabel Airuna  Airuna  Isabel
8  Jasmine  Foram   Foram Jasmine
9    Sudha Edward  Edward   Sudha
10   Jiten  Caleb   Caleb   Jiten
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
4 Airuna Isabel Airuna_Isabel          2         0                 1
7 Airuna Isabel Airuna_Isabel          2         0                 1
  DegreePercentile2 DegreePercentileProduct
4                 1                0.997193
7                 1                1.034535
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2           tag tag_counts selfpairs DegreePercentile1
5    Chris   Sudha   Chris_Sudha          1         0               0.2
10   Caleb   Jiten   Caleb_Jiten          1         0               0.8
2  Jasmine     Tes   Jasmine_Tes          1         0               0.8
1    Caleb  Edward  Caleb_Edward          1         0               0.8
8    Foram Jasmine Foram_Jasmine          1         0               0.8
9   Edward   Sudha  Edward_Sudha          1         0               0.8
3    Foram  Isabel  Foram_Isabel          1         0               0.8
6   Airuna     Tes    Airuna_Tes          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
5                0.8               0.1411139
10               0.2               0.1583135
2                0.8               0.6149833
1                0.8               0.6329789
8                0.8               0.6433775
9                0.8               0.6510382
3                1.0               0.7934431
6                0.8               0.8025192
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.796165968543217 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1      X2     X1      X2
1  Airuna   Caleb Airuna   Caleb
2  Isabel   Chris  Chris  Isabel
3 Jasmine  Airuna Airuna Jasmine
4  Edward     Tes Edward     Tes
5  Edward   Caleb  Caleb  Edward
6   Foram   Sudha  Foram   Sudha
7  Isabel Jasmine Isabel Jasmine
8   Sudha   Jiten  Jiten   Sudha
9  Isabel   Foram  Foram  Isabel
[1] "(rpns)ncycles= 99 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
2  Chris  Isabel   Chris_Isabel          1         0               0.2
8  Jiten   Sudha    Jiten_Sudha          1         0               0.2
5  Caleb  Edward   Caleb_Edward          1         0               0.8
4 Edward     Tes     Edward_Tes          1         0               0.8
6  Foram   Sudha    Foram_Sudha          1         0               0.8
9  Foram  Isabel   Foram_Isabel          1         0               0.8
1 Airuna   Caleb   Airuna_Caleb          1         0               1.0
3 Airuna Jasmine Airuna_Jasmine          1         0               1.0
7 Isabel Jasmine Isabel_Jasmine          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
2               1.0               0.1396753
8               0.8               0.1994179
5               0.8               0.6097036
4               0.8               0.6277394
6               0.8               0.6593327
9               1.0               0.7838863
1               0.8               0.7982864
3               0.8               0.8010963
7               0.8               0.8040334
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 99 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 9"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2      X1      X2
1    Foram   Caleb   Caleb   Foram
2    Foram  Airuna  Airuna   Foram
3    Caleb   Jiten   Caleb   Jiten
4   Isabel   Chris   Chris  Isabel
5    Sudha Jasmine Jasmine   Sudha
6      Tes  Edward  Edward     Tes
7      Tes   Sudha   Sudha     Tes
8   Isabel  Airuna  Airuna  Isabel
9  Jasmine  Isabel  Isabel Jasmine
10  Edward  Airuna  Airuna  Edward
[1] "(rpns)ncycles= 100 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2            tag tag_counts selfpairs DegreePercentile1
3    Caleb   Jiten    Caleb_Jiten          1         0               0.8
4    Chris  Isabel   Chris_Isabel          1         0               0.2
6   Edward     Tes     Edward_Tes          1         0               0.8
7    Sudha     Tes      Sudha_Tes          1         0               0.8
5  Jasmine   Sudha  Jasmine_Sudha          1         0               0.8
1    Caleb   Foram    Caleb_Foram          1         0               0.8
9   Isabel Jasmine Isabel_Jasmine          1         0               1.0
10  Airuna  Edward  Airuna_Edward          1         0               1.0
2   Airuna   Foram   Airuna_Foram          1         0               1.0
8   Airuna  Isabel  Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
3                0.2               0.1779583
4                1.0               0.2236734
6                0.8               0.6120134
7                0.8               0.6226030
5                0.8               0.6282552
1                0.8               0.6385875
9                0.8               0.7688949
10               0.8               0.8010262
2                0.8               0.8053736
8                1.0               1.0439051
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 100 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 10"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1     X2      X1     X2
1   Isabel Airuna  Airuna Isabel
2    Caleb Airuna  Airuna  Caleb
3  Jasmine    Tes Jasmine    Tes
4   Isabel Isabel  Isabel Isabel
5    Foram  Jiten   Foram  Jiten
6   Edward Edward  Edward Edward
7    Caleb    Tes   Caleb    Tes
8    Foram  Chris   Chris  Foram
9  Jasmine  Sudha Jasmine  Sudha
10   Sudha Airuna  Airuna  Sudha
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
6 Edward Edward Edward_Edward          1         1               0.8
4 Isabel Isabel Isabel_Isabel          1         1               1.0
  DegreePercentile2 DegreePercentileProduct
6               0.8               0.6740808
4               1.0               0.9701851
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1    id2           tag tag_counts selfpairs DegreePercentile1
5    Foram  Jiten   Foram_Jiten          1         0               0.8
8    Chris  Foram   Chris_Foram          1         0               0.2
3  Jasmine    Tes   Jasmine_Tes          1         0               0.8
7    Caleb    Tes     Caleb_Tes          1         0               0.8
9  Jasmine  Sudha Jasmine_Sudha          1         0               0.8
2   Airuna  Caleb  Airuna_Caleb          1         0               1.0
10  Airuna  Sudha  Airuna_Sudha          1         0               1.0
1   Airuna Isabel Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
5                0.2               0.1428560
8                0.8               0.1849615
3                0.8               0.6389652
7                0.8               0.6413395
9                0.8               0.6503608
2                0.8               0.7617409
10               0.8               0.8179680
1                1.0               0.9984772
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.872120795809409 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1      X2     X1      X2
1   Jiten  Airuna Airuna   Jiten
2   Foram  Isabel  Foram  Isabel
3 Jasmine   Caleb  Caleb Jasmine
4  Isabel   Sudha Isabel   Sudha
5     Tes  Airuna Airuna     Tes
6  Edward   Caleb  Caleb  Edward
7     Tes   Chris  Chris     Tes
8  Edward   Sudha Edward   Sudha
9   Foram Jasmine  Foram Jasmine
[1] "(rpns)ncycles= 99 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1     id2           tag tag_counts selfpairs DegreePercentile1
7  Chris     Tes     Chris_Tes          1         0               0.2
1 Airuna   Jiten  Airuna_Jiten          1         0               1.0
8 Edward   Sudha  Edward_Sudha          1         0               0.8
6  Caleb  Edward  Caleb_Edward          1         0               0.8
3  Caleb Jasmine Caleb_Jasmine          1         0               0.8
9  Foram Jasmine Foram_Jasmine          1         0               0.8
4 Isabel   Sudha  Isabel_Sudha          1         0               1.0
5 Airuna     Tes    Airuna_Tes          1         0               1.0
2  Foram  Isabel  Foram_Isabel          1         0               0.8
  DegreePercentile2 DegreePercentileProduct
7               0.8               0.1740796
1               0.2               0.2430671
8               0.8               0.6038089
6               0.8               0.6197546
3               0.8               0.6878058
9               0.8               0.6953905
4               0.8               0.7895872
5               0.8               0.8041190
2               1.0               0.8082489
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 99 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 9"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2      X1      X2
1    Caleb   Jiten   Caleb   Jiten
2    Caleb   Foram   Caleb   Foram
3      Tes Jasmine Jasmine     Tes
4   Airuna  Isabel  Airuna  Isabel
5    Chris   Foram   Chris   Foram
6  Jasmine  Airuna  Airuna Jasmine
7    Sudha  Edward  Edward   Sudha
8      Tes  Edward  Edward     Tes
9    Sudha  Airuna  Airuna   Sudha
10  Isabel  Isabel  Isabel  Isabel
[1] "(rpns)ncycles= 100 ===redopairs===="
      id1    id2           tag tag_counts selfpairs DegreePercentile1
10 Isabel Isabel Isabel_Isabel          1         1                 1
   DegreePercentile2 DegreePercentileProduct
10                 1                1.017956
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
5   Chris   Foram    Chris_Foram          1         0               0.2
1   Caleb   Jiten    Caleb_Jiten          1         0               0.8
7  Edward   Sudha   Edward_Sudha          1         0               0.8
8  Edward     Tes     Edward_Tes          1         0               0.8
2   Caleb   Foram    Caleb_Foram          1         0               0.8
3 Jasmine     Tes    Jasmine_Tes          1         0               0.8
6  Airuna Jasmine Airuna_Jasmine          1         0               1.0
9  Airuna   Sudha   Airuna_Sudha          1         0               1.0
4  Airuna  Isabel  Airuna_Isabel          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
5               0.8               0.1721159
1               0.2               0.1976420
7               0.8               0.6011105
8               0.8               0.6036639
2               0.8               0.6609869
3               0.8               0.6703669
6               0.8               0.8003665
9               0.8               0.8218722
4               1.0               1.0063273
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.858763190653469 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 9"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1     X2
1  Edward  Isabel  Edward Isabel
2 Jasmine   Sudha Jasmine  Sudha
3     Tes Jasmine Jasmine    Tes
4     Tes   Foram   Foram    Tes
5   Chris  Edward   Chris Edward
6   Sudha   Jiten   Jiten  Sudha
7  Airuna  Airuna  Airuna Airuna
8   Caleb   Caleb   Caleb  Caleb
9  Isabel   Foram   Foram Isabel
[1] "(rpns)ncycles= 99 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
8  Caleb  Caleb   Caleb_Caleb          1         1               0.8
7 Airuna Airuna Airuna_Airuna          1         1               1.0
  DegreePercentile2 DegreePercentileProduct
8               0.8               0.6266747
7               1.0               1.0011829
[1] "(rpns)ncycles= 99 ===restpairs===="
      id1    id2           tag tag_counts selfpairs DegreePercentile1
6   Jiten  Sudha   Jiten_Sudha          1         0               0.2
5   Chris Edward  Chris_Edward          1         0               0.2
4   Foram    Tes     Foram_Tes          1         0               0.8
2 Jasmine  Sudha Jasmine_Sudha          1         0               0.8
3 Jasmine    Tes   Jasmine_Tes          1         0               0.8
1  Edward Isabel Edward_Isabel          1         0               0.8
9   Foram Isabel  Foram_Isabel          1         0               0.8
  DegreePercentile2 DegreePercentileProduct
6               0.8               0.1737197
5               0.8               0.1807216
4               0.8               0.6298801
2               0.8               0.6324649
3               0.8               0.6369861
1               1.0               0.7932114
9               1.0               0.8232612
[1] "================="
[1] "(rpns) ncycles= 99 , degreeProduct.cutoff= 0.805231348219356 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 7"

** (rpns) Start ncycles= 98 , preserve_rate= 0.1 , length(inpairs[,1])= 8 **

[1] "===Before:Aftersort  ===="
       X1      X2     X1      X2
1   Caleb   Sudha  Caleb   Sudha
2   Jiten     Tes  Jiten     Tes
3   Chris   Foram  Chris   Foram
4  Isabel   Sudha Isabel   Sudha
5   Caleb  Edward  Caleb  Edward
6 Jasmine  Airuna Airuna Jasmine
7  Edward Jasmine Edward Jasmine
8     Tes  Airuna Airuna     Tes
[1] "(rpns)ncycles= 98 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 98 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
3  Chris   Foram    Chris_Foram          1         0               0.2
2  Jiten     Tes      Jiten_Tes          1         0               0.2
5  Caleb  Edward   Caleb_Edward          1         0               0.8
1  Caleb   Sudha    Caleb_Sudha          1         0               0.8
7 Edward Jasmine Edward_Jasmine          1         0               0.8
8 Airuna     Tes     Airuna_Tes          1         0               1.0
6 Airuna Jasmine Airuna_Jasmine          1         0               1.0
4 Isabel   Sudha   Isabel_Sudha          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
3               0.8               0.1828527
2               0.8               0.1969021
5               0.8               0.5981944
1               0.8               0.6156206
7               0.8               0.6637063
8               0.8               0.7949762
6               0.8               0.8114363
4               0.8               0.8318584
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 98 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 8"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2     X1      X2
1    Sudha  Edward Edward   Sudha
2    Caleb   Chris  Caleb   Chris
3   Airuna   Jiten Airuna   Jiten
4    Foram Jasmine  Foram Jasmine
5    Foram     Tes  Foram     Tes
6   Edward  Airuna Airuna  Edward
7   Isabel  Airuna Airuna  Isabel
8   Isabel   Caleb  Caleb  Isabel
9  Jasmine  Isabel Isabel Jasmine
10   Sudha     Tes  Sudha     Tes
[1] "(rpns)ncycles= 100 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
2   Caleb   Chris    Caleb_Chris          1         0               0.8
3  Airuna   Jiten   Airuna_Jiten          1         0               1.0
5   Foram     Tes      Foram_Tes          1         0               0.8
1  Edward   Sudha   Edward_Sudha          1         0               0.8
4   Foram Jasmine  Foram_Jasmine          1         0               0.8
10  Sudha     Tes      Sudha_Tes          1         0               0.8
9  Isabel Jasmine Isabel_Jasmine          1         0               1.0
6  Airuna  Edward  Airuna_Edward          1         0               1.0
8   Caleb  Isabel   Caleb_Isabel          1         0               0.8
7  Airuna  Isabel  Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
2                0.2               0.1707443
3                0.2               0.1975232
5                0.8               0.6094962
1                0.8               0.6140264
4                0.8               0.6690130
10               0.8               0.6810057
9                0.8               0.7699291
6                0.8               0.7788208
8                1.0               0.8309094
7                1.0               1.0083353
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 100 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 10"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1  Isabel  Airuna  Airuna  Isabel
2  Edward Jasmine  Edward Jasmine
3     Tes Jasmine Jasmine     Tes
4   Chris   Caleb   Caleb   Chris
5   Sudha   Foram   Foram   Sudha
6  Isabel   Jiten  Isabel   Jiten
7   Sudha   Foram   Foram   Sudha
8  Airuna   Caleb  Airuna   Caleb
9     Tes  Edward  Edward     Tes
10 Airuna  Isabel  Airuna  Isabel
[1] "(rpns)ncycles= 100 ===redopairs===="
      id1    id2           tag tag_counts selfpairs DegreePercentile1
7   Foram  Sudha   Foram_Sudha          2         0               0.8
5   Foram  Sudha   Foram_Sudha          2         0               0.8
1  Airuna Isabel Airuna_Isabel          2         0               1.0
10 Airuna Isabel Airuna_Isabel          2         0               1.0
   DegreePercentile2 DegreePercentileProduct
7                0.8               0.6541450
5                0.8               0.6828008
1                1.0               0.9703636
10               1.0               1.0063475
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
4   Caleb   Chris    Caleb_Chris          1         0               0.8
6  Isabel   Jiten   Isabel_Jiten          1         0               1.0
9  Edward     Tes     Edward_Tes          1         0               0.8
3 Jasmine     Tes    Jasmine_Tes          1         0               0.8
2  Edward Jasmine Edward_Jasmine          1         0               0.8
8  Airuna   Caleb   Airuna_Caleb          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
4               0.2               0.1663940
6               0.2               0.1910779
9               0.8               0.6191657
3               0.8               0.6434882
2               0.8               0.6801033
8               0.8               0.7921388
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.736121052406707 , length(redo.tb[,1])= 4 , length(rest.tb[,1])= 6"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1      X2     X1      X2
1   Foram  Isabel  Foram  Isabel
2   Foram Jasmine  Foram Jasmine
3   Caleb  Edward  Caleb  Edward
4 Jasmine  Isabel Isabel Jasmine
5  Airuna  Edward Airuna  Edward
6   Sudha     Tes  Sudha     Tes
7     Tes  Airuna Airuna     Tes
8   Sudha   Jiten  Jiten   Sudha
9   Chris  Isabel  Chris  Isabel
[1] "(rpns)ncycles= 99 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
8  Jiten   Sudha    Jiten_Sudha          1         0               0.2
9  Chris  Isabel   Chris_Isabel          1         0               0.2
3  Caleb  Edward   Caleb_Edward          1         0               0.8
6  Sudha     Tes      Sudha_Tes          1         0               0.8
2  Foram Jasmine  Foram_Jasmine          1         0               0.8
1  Foram  Isabel   Foram_Isabel          1         0               0.8
5 Airuna  Edward  Airuna_Edward          1         0               1.0
4 Isabel Jasmine Isabel_Jasmine          1         0               1.0
7 Airuna     Tes     Airuna_Tes          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
8               0.8               0.1561430
9               1.0               0.1780004
3               0.8               0.6174078
6               0.8               0.6273706
2               0.8               0.6447258
1               1.0               0.7568433
5               0.8               0.7744911
4               0.8               0.8447969
7               0.8               0.8466303
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 99 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 9"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2      X1      X2
1    Foram   Sudha   Foram   Sudha
2    Caleb  Airuna  Airuna   Caleb
3  Jasmine  Isabel  Isabel Jasmine
4   Edward  Isabel  Edward  Isabel
5   Airuna   Caleb  Airuna   Caleb
6      Tes  Edward  Edward     Tes
7    Chris   Foram   Chris   Foram
8      Tes Jasmine Jasmine     Tes
9   Isabel  Airuna  Airuna  Isabel
10   Jiten   Sudha   Jiten   Sudha
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1   id2          tag tag_counts selfpairs DegreePercentile1
5 Airuna Caleb Airuna_Caleb          2         0                 1
2 Airuna Caleb Airuna_Caleb          2         0                 1
  DegreePercentile2 DegreePercentileProduct
5               0.8               0.7941888
2               0.8               0.8330407
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2            tag tag_counts selfpairs DegreePercentile1
10   Jiten   Sudha    Jiten_Sudha          1         0               0.2
7    Chris   Foram    Chris_Foram          1         0               0.2
6   Edward     Tes     Edward_Tes          1         0               0.8
8  Jasmine     Tes    Jasmine_Tes          1         0               0.8
1    Foram   Sudha    Foram_Sudha          1         0               0.8
3   Isabel Jasmine Isabel_Jasmine          1         0               1.0
4   Edward  Isabel  Edward_Isabel          1         0               0.8
9   Airuna  Isabel  Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
10               0.8               0.1688810
7                0.8               0.1753769
6                0.8               0.6052829
8                0.8               0.6242218
1                0.8               0.6409660
3                0.8               0.7823112
4                1.0               0.8021031
9                1.0               0.9714438
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.85290530198005 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1  Edward  Isabel  Edward  Isabel
2   Foram  Edward  Edward   Foram
3   Caleb   Caleb   Caleb   Caleb
4  Isabel  Airuna  Airuna  Isabel
5  Airuna     Tes  Airuna     Tes
6 Jasmine   Chris   Chris Jasmine
7   Foram   Sudha   Foram   Sudha
8     Tes   Sudha   Sudha     Tes
9   Jiten Jasmine Jasmine   Jiten
[1] "(rpns)ncycles= 99 ===redopairs===="
    id1   id2         tag tag_counts selfpairs DegreePercentile1
3 Caleb Caleb Caleb_Caleb          1         1               0.8
  DegreePercentile2 DegreePercentileProduct
3               0.8               0.6242846
[1] "(rpns)ncycles= 99 ===restpairs===="
      id1     id2           tag tag_counts selfpairs DegreePercentile1
6   Chris Jasmine Chris_Jasmine          1         0               0.2
9 Jasmine   Jiten Jasmine_Jiten          1         0               0.8
2  Edward   Foram  Edward_Foram          1         0               0.8
8   Sudha     Tes     Sudha_Tes          1         0               0.8
7   Foram   Sudha   Foram_Sudha          1         0               0.8
1  Edward  Isabel Edward_Isabel          1         0               0.8
5  Airuna     Tes    Airuna_Tes          1         0               1.0
4  Airuna  Isabel Airuna_Isabel          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
6               0.8               0.1339164
9               0.2               0.1813353
2               0.8               0.6276232
8               0.8               0.6402539
7               0.8               0.6439577
1               1.0               0.7900050
5               0.8               0.8453157
4               1.0               0.9792536
[1] "================="
[1] "(rpns) ncycles= 99 , degreeProduct.cutoff= 0.885497059370193 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 98 , preserve_rate= 0.1 , length(inpairs[,1])= 8 **

[1] "===Before:Aftersort  ===="
      X1      X2      X1      X2
1 Isabel  Airuna  Airuna  Isabel
2    Tes Jasmine Jasmine     Tes
3  Sudha   Caleb   Caleb   Sudha
4  Jiten   Foram   Foram   Jiten
5    Tes   Chris   Chris     Tes
6 Edward Jasmine  Edward Jasmine
7  Foram  Edward  Edward   Foram
8  Sudha   Caleb   Caleb   Sudha
[1] "(rpns)ncycles= 98 ===redopairs===="
    id1   id2         tag tag_counts selfpairs DegreePercentile1
8 Caleb Sudha Caleb_Sudha          2         0               0.8
3 Caleb Sudha Caleb_Sudha          2         0               0.8
  DegreePercentile2 DegreePercentileProduct
8               0.8               0.6315409
3               0.8               0.6788041
[1] "(rpns)ncycles= 98 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
5   Chris     Tes      Chris_Tes          1         0               0.2
4   Foram   Jiten    Foram_Jiten          1         0               0.8
2 Jasmine     Tes    Jasmine_Tes          1         0               0.8
7  Edward   Foram   Edward_Foram          1         0               0.8
6  Edward Jasmine Edward_Jasmine          1         0               0.8
1  Airuna  Isabel  Airuna_Isabel          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
5               0.8               0.1586848
4               0.2               0.1648599
2               0.8               0.6063219
7               0.8               0.6229884
6               0.8               0.6495971
1               1.0               1.0354285
[1] "================="
[1] "(rpns) ncycles= 98 , degreeProduct.cutoff= 0.842512798728046 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 6"

** (rpns) Start ncycles= 97 , preserve_rate= 0.1 , length(inpairs[,1])= 7 **

[1] "===Before:Aftersort  ===="
     X1      X2     X1      X2
1   Tes     Tes    Tes     Tes
2 Caleb Jasmine  Caleb Jasmine
3 Jiten   Foram  Foram   Jiten
4 Foram   Chris  Chris   Foram
5 Sudha  Edward Edward   Sudha
6 Caleb Jasmine  Caleb Jasmine
7 Sudha  Edward Edward   Sudha
[1] "(rpns)ncycles= 97 ===redopairs===="
     id1     id2           tag tag_counts selfpairs DegreePercentile1
1    Tes     Tes       Tes_Tes          1         1               0.8
2  Caleb Jasmine Caleb_Jasmine          2         0               0.8
7 Edward   Sudha  Edward_Sudha          2         0               0.8
6  Caleb Jasmine Caleb_Jasmine          2         0               0.8
5 Edward   Sudha  Edward_Sudha          2         0               0.8
  DegreePercentile2 DegreePercentileProduct
1               0.8               0.5628038
2               0.8               0.5857282
7               0.8               0.5894527
6               0.8               0.6114470
5               0.8               0.6795615
[1] "(rpns)ncycles= 97 ===restpairs===="
    id1   id2         tag tag_counts selfpairs DegreePercentile1
3 Foram Jiten Foram_Jiten          1         0               0.8
4 Chris Foram Chris_Foram          1         0               0.2
  DegreePercentile2 DegreePercentileProduct
3               0.2               0.1349869
4               0.8               0.1404693
[1] "================="
[1] "(rpns) ncycles= 97 , degreeProduct.cutoff= 0.139921039194083 , length(redo.tb[,1])= 5 , length(rest.tb[,1])= 2"

** (rpns) Start ncycles= 96 , preserve_rate= 0.1 , length(inpairs[,1])= 6 **

[1] "===Before:Aftersort  ===="
       X1     X2     X1      X2
1 Jasmine  Caleb  Caleb Jasmine
2 Jasmine Edward Edward Jasmine
3  Edward    Tes Edward     Tes
4   Foram  Sudha  Foram   Sudha
5   Sudha    Tes  Sudha     Tes
6   Caleb  Jiten  Caleb   Jiten
[1] "(rpns)ncycles= 96 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 96 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
6  Caleb   Jiten    Caleb_Jiten          1         0               0.8
1  Caleb Jasmine  Caleb_Jasmine          1         0               0.8
4  Foram   Sudha    Foram_Sudha          1         0               0.8
2 Edward Jasmine Edward_Jasmine          1         0               0.8
3 Edward     Tes     Edward_Tes          1         0               0.8
5  Sudha     Tes      Sudha_Tes          1         0               0.8
  DegreePercentile2 DegreePercentileProduct
6               0.2               0.1907653
1               0.8               0.6023503
4               0.8               0.6518696
2               0.8               0.6584136
3               0.8               0.6672898
5               0.8               0.6853542
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 96 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 6"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2      X1      X2
1    Foram   Caleb   Caleb   Foram
2   Airuna   Caleb  Airuna   Caleb
3    Chris   Jiten   Chris   Jiten
4   Airuna Jasmine  Airuna Jasmine
5  Jasmine     Tes Jasmine     Tes
6    Sudha   Foram   Foram   Sudha
7      Tes  Edward  Edward     Tes
8    Sudha  Edward  Edward   Sudha
9   Isabel  Isabel  Isabel  Isabel
10  Airuna  Isabel  Airuna  Isabel
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
9 Isabel Isabel Isabel_Isabel          1         1                 1
  DegreePercentile2 DegreePercentileProduct
9                 1               0.9673287
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2            tag tag_counts selfpairs DegreePercentile1
3    Chris   Jiten    Chris_Jiten          1         0               0.2
6    Foram   Sudha    Foram_Sudha          1         0               0.8
7   Edward     Tes     Edward_Tes          1         0               0.8
5  Jasmine     Tes    Jasmine_Tes          1         0               0.8
1    Caleb   Foram    Caleb_Foram          1         0               0.8
8   Edward   Sudha   Edward_Sudha          1         0               0.8
2   Airuna   Caleb   Airuna_Caleb          1         0               1.0
4   Airuna Jasmine Airuna_Jasmine          1         0               1.0
10  Airuna  Isabel  Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
3                0.2               0.0581910
6                0.8               0.6088018
7                0.8               0.6101980
5                0.8               0.6173116
1                0.8               0.6226453
8                0.8               0.6241853
2                0.8               0.8223034
4                0.8               0.8237345
10               1.0               1.0015580
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.859299196286313 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 9"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1     X2     X1      X2
1   Chris Airuna Airuna   Chris
2  Edward    Tes Edward     Tes
3   Caleb  Jiten  Caleb   Jiten
4 Jasmine Isabel Isabel Jasmine
5 Jasmine Airuna Airuna Jasmine
6   Caleb Isabel  Caleb  Isabel
7   Sudha    Tes  Sudha     Tes
8  Edward  Sudha Edward   Sudha
9   Foram  Foram  Foram   Foram
[1] "(rpns)ncycles= 99 ===redopairs===="
    id1   id2         tag tag_counts selfpairs DegreePercentile1
9 Foram Foram Foram_Foram          1         1               0.8
  DegreePercentile2 DegreePercentileProduct
9               0.8               0.5833957
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
3  Caleb   Jiten    Caleb_Jiten          1         0               0.8
1 Airuna   Chris   Airuna_Chris          1         0               1.0
8 Edward   Sudha   Edward_Sudha          1         0               0.8
7  Sudha     Tes      Sudha_Tes          1         0               0.8
2 Edward     Tes     Edward_Tes          1         0               0.8
5 Airuna Jasmine Airuna_Jasmine          1         0               1.0
4 Isabel Jasmine Isabel_Jasmine          1         0               1.0
6  Caleb  Isabel   Caleb_Isabel          1         0               0.8
  DegreePercentile2 DegreePercentileProduct
3               0.2               0.1568604
1               0.2               0.2048227
8               0.8               0.6188824
7               0.8               0.6423283
2               0.8               0.6433978
5               0.8               0.7717571
4               0.8               0.7780460
6               1.0               0.8006456
[1] "================="
[1] "(rpns) ncycles= 99 , degreeProduct.cutoff= 0.784825874542026 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 98 , preserve_rate= 0.1 , length(inpairs[,1])= 8 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1   Jiten  Airuna  Airuna   Jiten
2   Foram  Isabel   Foram  Isabel
3   Sudha   Chris   Chris   Sudha
4  Edward     Tes  Edward     Tes
5  Edward     Tes  Edward     Tes
6   Sudha   Foram   Foram   Sudha
7   Caleb  Airuna  Airuna   Caleb
8 Jasmine Jasmine Jasmine Jasmine
[1] "(rpns)ncycles= 98 ===redopairs===="
      id1     id2             tag tag_counts selfpairs DegreePercentile1
5  Edward     Tes      Edward_Tes          2         0               0.8
4  Edward     Tes      Edward_Tes          2         0               0.8
8 Jasmine Jasmine Jasmine_Jasmine          1         1               0.8
  DegreePercentile2 DegreePercentileProduct
5               0.8               0.6292823
4               0.8               0.6375984
8               0.8               0.6391374
[1] "(rpns)ncycles= 98 ===restpairs===="
     id1    id2          tag tag_counts selfpairs DegreePercentile1
3  Chris  Sudha  Chris_Sudha          1         0               0.2
1 Airuna  Jiten Airuna_Jiten          1         0               1.0
6  Foram  Sudha  Foram_Sudha          1         0               0.8
2  Foram Isabel Foram_Isabel          1         0               0.8
7 Airuna  Caleb Airuna_Caleb          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
3               0.8               0.1450336
1               0.2               0.2033901
6               0.8               0.6494075
2               1.0               0.8109355
7               0.8               0.8506305
[1] "================="
[1] "(rpns) ncycles= 98 , degreeProduct.cutoff= 0.834752511570845 , length(redo.tb[,1])= 3 , length(rest.tb[,1])= 5"

** (rpns) Start ncycles= 97 , preserve_rate= 0.1 , length(inpairs[,1])= 7 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1  Airuna   Jiten  Airuna   Jiten
2   Sudha   Foram   Foram   Sudha
3   Foram   Chris   Chris   Foram
4 Jasmine  Edward  Edward Jasmine
5     Tes  Isabel  Isabel     Tes
6  Edward   Sudha  Edward   Sudha
7     Tes Jasmine Jasmine     Tes
[1] "(rpns)ncycles= 97 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 97 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
1  Airuna   Jiten   Airuna_Jiten          1         0               1.0
3   Chris   Foram    Chris_Foram          1         0               0.2
7 Jasmine     Tes    Jasmine_Tes          1         0               0.8
6  Edward   Sudha   Edward_Sudha          1         0               0.8
4  Edward Jasmine Edward_Jasmine          1         0               0.8
2   Foram   Sudha    Foram_Sudha          1         0               0.8
5  Isabel     Tes     Isabel_Tes          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
1               0.2               0.1616219
3               0.8               0.1953705
7               0.8               0.6260836
6               0.8               0.6262136
4               0.8               0.6416697
2               0.8               0.6540775
5               0.8               0.8103675
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 97 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 7"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2      X1      X2
1    Foram   Caleb   Caleb   Foram
2    Caleb     Tes   Caleb     Tes
3  Jasmine     Tes Jasmine     Tes
4   Isabel Jasmine  Isabel Jasmine
5    Sudha  Edward  Edward   Sudha
6    Sudha  Edward  Edward   Sudha
7    Foram  Airuna  Airuna   Foram
8   Airuna  Airuna  Airuna  Airuna
9   Isabel  Isabel  Isabel  Isabel
10   Jiten   Chris   Chris   Jiten
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
6 Edward  Sudha  Edward_Sudha          2         0               0.8
5 Edward  Sudha  Edward_Sudha          2         0               0.8
8 Airuna Airuna Airuna_Airuna          1         1               1.0
9 Isabel Isabel Isabel_Isabel          1         1               1.0
  DegreePercentile2 DegreePercentileProduct
6               0.8               0.6643811
5               0.8               0.6695758
8               1.0               1.0198416
9               1.0               1.0219164
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2            tag tag_counts selfpairs DegreePercentile1
10   Chris   Jiten    Chris_Jiten          1         0               0.2
3  Jasmine     Tes    Jasmine_Tes          1         0               0.8
2    Caleb     Tes      Caleb_Tes          1         0               0.8
1    Caleb   Foram    Caleb_Foram          1         0               0.8
4   Isabel Jasmine Isabel_Jasmine          1         0               1.0
7   Airuna   Foram   Airuna_Foram          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
10               0.2             0.008456325
3                0.8             0.627219728
2                0.8             0.628792486
1                0.8             0.651295721
4                0.8             0.825511326
7                0.8             0.832210639
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.828860982517225 , length(redo.tb[,1])= 4 , length(rest.tb[,1])= 6"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1      X2     X1      X2
1  Isabel  Isabel Isabel  Isabel
2  Edward   Sudha Edward   Sudha
3   Sudha  Isabel Isabel   Sudha
4   Chris   Jiten  Chris   Jiten
5   Foram Jasmine  Foram Jasmine
6   Caleb     Tes  Caleb     Tes
7  Airuna  Edward Airuna  Edward
8     Tes   Caleb  Caleb     Tes
9 Jasmine  Airuna Airuna Jasmine
[1] "(rpns)ncycles= 99 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
6  Caleb    Tes     Caleb_Tes          2         0               0.8
8  Caleb    Tes     Caleb_Tes          2         0               0.8
1 Isabel Isabel Isabel_Isabel          1         1               1.0
  DegreePercentile2 DegreePercentileProduct
6               0.8               0.6011910
8               0.8               0.6496468
1               1.0               0.9640805
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
4  Chris   Jiten    Chris_Jiten          1         0               0.2
2 Edward   Sudha   Edward_Sudha          1         0               0.8
5  Foram Jasmine  Foram_Jasmine          1         0               0.8
7 Airuna  Edward  Airuna_Edward          1         0               1.0
3 Isabel   Sudha   Isabel_Sudha          1         0               1.0
9 Airuna Jasmine Airuna_Jasmine          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
4               0.2              0.03992575
2               0.8              0.61859937
5               0.8              0.62147686
7               0.8              0.79341853
3               0.8              0.80565889
9               0.8              0.81825171
[1] "================="
[1] "(rpns) ncycles= 99 , degreeProduct.cutoff= 0.81195530082459 , length(redo.tb[,1])= 3 , length(rest.tb[,1])= 6"

** (rpns) Start ncycles= 98 , preserve_rate= 0.1 , length(inpairs[,1])= 8 **

[1] "===Before:Aftersort  ===="
       X1     X2     X1      X2
1  Isabel    Tes Isabel     Tes
2  Edward  Jiten Edward   Jiten
3   Sudha Edward Edward   Sudha
4   Caleb  Foram  Caleb   Foram
5  Airuna Isabel Airuna  Isabel
6     Tes  Sudha  Sudha     Tes
7 Jasmine Isabel Isabel Jasmine
8   Caleb  Chris  Caleb   Chris
[1] "(rpns)ncycles= 98 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 98 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
2 Edward   Jiten   Edward_Jiten          1         0               0.8
8  Caleb   Chris    Caleb_Chris          1         0               0.8
6  Sudha     Tes      Sudha_Tes          1         0               0.8
3 Edward   Sudha   Edward_Sudha          1         0               0.8
4  Caleb   Foram    Caleb_Foram          1         0               0.8
1 Isabel     Tes     Isabel_Tes          1         0               1.0
7 Isabel Jasmine Isabel_Jasmine          1         0               1.0
5 Airuna  Isabel  Airuna_Isabel          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
2               0.2               0.1748161
8               0.2               0.1982041
6               0.8               0.6192587
3               0.8               0.6344833
4               0.8               0.6821842
1               0.8               0.8050742
7               0.8               0.8402909
5               1.0               0.9916951
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 98 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 8"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2     X1      X2
1    Foram  Airuna Airuna   Foram
2   Isabel Jasmine Isabel Jasmine
3    Foram   Caleb  Caleb   Foram
4    Sudha   Jiten  Jiten   Sudha
5   Edward     Tes Edward     Tes
6    Sudha  Isabel Isabel   Sudha
7  Jasmine  Airuna Airuna Jasmine
8   Airuna   Chris Airuna   Chris
9   Edward     Tes Edward     Tes
10  Isabel   Caleb  Caleb  Isabel
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1 id2        tag tag_counts selfpairs DegreePercentile1
5 Edward Tes Edward_Tes          2         0               0.8
9 Edward Tes Edward_Tes          2         0               0.8
  DegreePercentile2 DegreePercentileProduct
5               0.8               0.6351326
9               0.8               0.6387052
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
4   Jiten   Sudha    Jiten_Sudha          1         0               0.2
8  Airuna   Chris   Airuna_Chris          1         0               1.0
3   Caleb   Foram    Caleb_Foram          1         0               0.8
2  Isabel Jasmine Isabel_Jasmine          1         0               1.0
10  Caleb  Isabel   Caleb_Isabel          1         0               0.8
1  Airuna   Foram   Airuna_Foram          1         0               1.0
7  Airuna Jasmine Airuna_Jasmine          1         0               1.0
6  Isabel   Sudha   Isabel_Sudha          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
4                0.8               0.1603482
8                0.2               0.1919365
3                0.8               0.5976676
2                0.8               0.7840562
10               1.0               0.8026202
1                0.8               0.8090177
7                0.8               0.8345785
6                0.8               0.8660106
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.844008091184191 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
      X1      X2     X1      X2
1  Caleb   Foram  Caleb   Foram
2 Edward Jasmine Edward Jasmine
3 Airuna  Airuna Airuna  Airuna
4  Chris  Isabel  Chris  Isabel
5    Tes   Sudha  Sudha     Tes
6 Airuna Jasmine Airuna Jasmine
7  Foram   Caleb  Caleb   Foram
8  Jiten  Isabel Isabel   Jiten
9    Tes  Edward Edward     Tes
[1] "(rpns)ncycles= 99 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
7  Caleb  Foram   Caleb_Foram          2         0               0.8
1  Caleb  Foram   Caleb_Foram          2         0               0.8
3 Airuna Airuna Airuna_Airuna          1         1               1.0
  DegreePercentile2 DegreePercentileProduct
7               0.8               0.6145802
1               0.8               0.6738243
3               1.0               0.9719193
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
4  Chris  Isabel   Chris_Isabel          1         0               0.2
8 Isabel   Jiten   Isabel_Jiten          1         0               1.0
9 Edward     Tes     Edward_Tes          1         0               0.8
2 Edward Jasmine Edward_Jasmine          1         0               0.8
5  Sudha     Tes      Sudha_Tes          1         0               0.8
6 Airuna Jasmine Airuna_Jasmine          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
4               1.0               0.1501266
8               0.2               0.1929635
9               0.8               0.6072844
2               0.8               0.6317186
5               0.8               0.6445776
6               0.8               0.7795222
[1] "================="
[1] "(rpns) ncycles= 99 , degreeProduct.cutoff= 0.712049887477159 , length(redo.tb[,1])= 3 , length(rest.tb[,1])= 6"

** (rpns) Start ncycles= 98 , preserve_rate= 0.1 , length(inpairs[,1])= 8 **

[1] "===Before:Aftersort  ===="
       X1     X2     X1      X2
1  Airuna Isabel Airuna  Isabel
2  Airuna  Foram Airuna   Foram
3   Caleb  Foram  Caleb   Foram
4     Tes  Jiten  Jiten     Tes
5 Jasmine Isabel Isabel Jasmine
6  Edward Edward Edward  Edward
7   Caleb  Sudha  Caleb   Sudha
8   Chris    Tes  Chris     Tes
[1] "(rpns)ncycles= 98 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
6 Edward Edward Edward_Edward          1         1               0.8
  DegreePercentile2 DegreePercentileProduct
6               0.8               0.6554116
[1] "(rpns)ncycles= 98 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
8  Chris     Tes      Chris_Tes          1         0               0.2
4  Jiten     Tes      Jiten_Tes          1         0               0.2
7  Caleb   Sudha    Caleb_Sudha          1         0               0.8
3  Caleb   Foram    Caleb_Foram          1         0               0.8
5 Isabel Jasmine Isabel_Jasmine          1         0               1.0
2 Airuna   Foram   Airuna_Foram          1         0               1.0
1 Airuna  Isabel  Airuna_Isabel          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
8               0.8               0.1276795
4               0.8               0.2091548
7               0.8               0.6071091
3               0.8               0.6494633
5               0.8               0.7916829
2               0.8               0.8568878
1               1.0               1.0058605
[1] "================="
[1] "(rpns) ncycles= 98 , degreeProduct.cutoff= 0.916476856565498 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 7"

** (rpns) Start ncycles= 97 , preserve_rate= 0.1 , length(inpairs[,1])= 7 **

[1] "===Before:Aftersort  ===="
       X1     X2      X1     X2
1   Foram  Caleb   Caleb  Foram
2  Edward  Jiten  Edward  Jiten
3  Edward  Sudha  Edward  Sudha
4  Isabel  Chris   Chris Isabel
5 Jasmine    Tes Jasmine    Tes
6   Caleb Airuna  Airuna  Caleb
7   Foram    Tes   Foram    Tes
[1] "(rpns)ncycles= 97 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 97 ===restpairs===="
      id1    id2          tag tag_counts selfpairs DegreePercentile1
2  Edward  Jiten Edward_Jiten          1         0               0.8
4   Chris Isabel Chris_Isabel          1         0               0.2
1   Caleb  Foram  Caleb_Foram          1         0               0.8
5 Jasmine    Tes  Jasmine_Tes          1         0               0.8
3  Edward  Sudha Edward_Sudha          1         0               0.8
7   Foram    Tes    Foram_Tes          1         0               0.8
6  Airuna  Caleb Airuna_Caleb          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
2               0.2               0.1545627
4               1.0               0.1569693
1               0.8               0.6246239
5               0.8               0.6582612
3               0.8               0.6815653
7               0.8               0.6853276
6               0.8               0.8373982
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 97 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 7"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1  Edward   Caleb   Caleb  Edward
2  Airuna Jasmine  Airuna Jasmine
3  Isabel  Airuna  Airuna  Isabel
4  Airuna   Caleb  Airuna   Caleb
5   Chris     Tes   Chris     Tes
6   Foram   Jiten   Foram   Jiten
7  Isabel  Edward  Edward  Isabel
8     Tes   Foram   Foram     Tes
9   Sudha Jasmine Jasmine   Sudha
10 Isabel   Sudha  Isabel   Sudha
[1] "(rpns)ncycles= 100 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2            tag tag_counts selfpairs DegreePercentile1
6    Foram   Jiten    Foram_Jiten          1         0               0.8
5    Chris     Tes      Chris_Tes          1         0               0.2
1    Caleb  Edward   Caleb_Edward          1         0               0.8
9  Jasmine   Sudha  Jasmine_Sudha          1         0               0.8
8    Foram     Tes      Foram_Tes          1         0               0.8
4   Airuna   Caleb   Airuna_Caleb          1         0               1.0
10  Isabel   Sudha   Isabel_Sudha          1         0               1.0
2   Airuna Jasmine Airuna_Jasmine          1         0               1.0
7   Edward  Isabel  Edward_Isabel          1         0               0.8
3   Airuna  Isabel  Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
6                0.2               0.1518233
5                0.8               0.1691116
1                0.8               0.5846378
9                0.8               0.6786154
8                0.8               0.6871604
4                0.8               0.7711814
10               0.8               0.7748600
2                0.8               0.7865497
7                1.0               0.8275198
3                1.0               1.0468911
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 100 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 10"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1     X2     X1      X2
1  Jasmine Isabel Isabel Jasmine
2   Isabel Isabel Isabel  Isabel
3    Caleb Edward  Caleb  Edward
4    Sudha  Sudha  Sudha   Sudha
5   Airuna Edward Airuna  Edward
6      Tes  Jiten  Jiten     Tes
7   Airuna Airuna Airuna  Airuna
8  Jasmine  Chris  Chris Jasmine
9      Tes  Foram  Foram     Tes
10   Foram  Caleb  Caleb   Foram
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
4  Sudha  Sudha   Sudha_Sudha          1         1               0.8
2 Isabel Isabel Isabel_Isabel          1         1               1.0
7 Airuna Airuna Airuna_Airuna          1         1               1.0
  DegreePercentile2 DegreePercentileProduct
4               0.8               0.6759263
2               1.0               0.9621012
7               1.0               0.9626603
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
8   Chris Jasmine  Chris_Jasmine          1         0               0.2
6   Jiten     Tes      Jiten_Tes          1         0               0.2
9   Foram     Tes      Foram_Tes          1         0               0.8
10  Caleb   Foram    Caleb_Foram          1         0               0.8
3   Caleb  Edward   Caleb_Edward          1         0               0.8
5  Airuna  Edward  Airuna_Edward          1         0               1.0
1  Isabel Jasmine Isabel_Jasmine          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
8                0.8               0.1405082
6                0.8               0.1490738
9                0.8               0.6249381
10               0.8               0.6539769
3                0.8               0.6855289
5                0.8               0.7435671
1                0.8               0.7975030
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.765141455484708 , length(redo.tb[,1])= 3 , length(rest.tb[,1])= 7"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
      X1      X2     X1      X2
1 Airuna  Edward Airuna  Edward
2    Tes  Isabel Isabel     Tes
3  Sudha   Foram  Foram   Sudha
4 Isabel  Airuna Airuna  Isabel
5 Edward Jasmine Edward Jasmine
6 Airuna   Caleb Airuna   Caleb
7  Jiten   Foram  Foram   Jiten
8  Chris   Caleb  Caleb   Chris
9    Tes   Sudha  Sudha     Tes
[1] "(rpns)ncycles= 99 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
7  Foram   Jiten    Foram_Jiten          1         0               0.8
8  Caleb   Chris    Caleb_Chris          1         0               0.8
5 Edward Jasmine Edward_Jasmine          1         0               0.8
9  Sudha     Tes      Sudha_Tes          1         0               0.8
3  Foram   Sudha    Foram_Sudha          1         0               0.8
2 Isabel     Tes     Isabel_Tes          1         0               1.0
6 Airuna   Caleb   Airuna_Caleb          1         0               1.0
1 Airuna  Edward  Airuna_Edward          1         0               1.0
4 Airuna  Isabel  Airuna_Isabel          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
7               0.2               0.1387398
8               0.2               0.1550083
5               0.8               0.5919771
9               0.8               0.6419464
3               0.8               0.6749036
2               0.8               0.7616807
6               0.8               0.7868347
1               0.8               0.7910638
4               1.0               0.9975875
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 99 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 9"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2      X1      X2
1   Airuna   Foram  Airuna   Foram
2  Jasmine     Tes Jasmine     Tes
3   Edward   Caleb   Caleb  Edward
4   Isabel  Airuna  Airuna  Isabel
5   Edward  Isabel  Edward  Isabel
6   Isabel   Jiten  Isabel   Jiten
7      Tes   Foram   Foram     Tes
8    Chris Jasmine   Chris Jasmine
9    Caleb   Sudha   Caleb   Sudha
10   Sudha  Airuna  Airuna   Sudha
[1] "(rpns)ncycles= 100 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2           tag tag_counts selfpairs DegreePercentile1
8    Chris Jasmine Chris_Jasmine          1         0               0.2
6   Isabel   Jiten  Isabel_Jiten          1         0               1.0
9    Caleb   Sudha   Caleb_Sudha          1         0               0.8
7    Foram     Tes     Foram_Tes          1         0               0.8
2  Jasmine     Tes   Jasmine_Tes          1         0               0.8
3    Caleb  Edward  Caleb_Edward          1         0               0.8
1   Airuna   Foram  Airuna_Foram          1         0               1.0
10  Airuna   Sudha  Airuna_Sudha          1         0               1.0
5   Edward  Isabel Edward_Isabel          1         0               0.8
4   Airuna  Isabel Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
8                0.8               0.1627230
6                0.2               0.1701162
9                0.8               0.6075726
7                0.8               0.6230465
2                0.8               0.6440094
3                0.8               0.6830460
1                0.8               0.7887970
10               0.8               0.8188723
5                1.0               0.8341475
4                1.0               0.9870652
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 100 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 10"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1     X2     X1      X2
1    Caleb Isabel  Caleb  Isabel
2    Sudha  Sudha  Sudha   Sudha
3   Edward  Caleb  Caleb  Edward
4  Jasmine Airuna Airuna Jasmine
5    Foram  Jiten  Foram   Jiten
6  Jasmine Isabel Isabel Jasmine
7   Isabel    Tes Isabel     Tes
8    Chris Airuna Airuna   Chris
9   Edward    Tes Edward     Tes
10  Airuna  Foram Airuna   Foram
[1] "(rpns)ncycles= 100 ===redopairs===="
    id1   id2         tag tag_counts selfpairs DegreePercentile1
2 Sudha Sudha Sudha_Sudha          1         1               0.8
  DegreePercentile2 DegreePercentileProduct
2               0.8               0.6681699
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
8  Airuna   Chris   Airuna_Chris          1         0               1.0
5   Foram   Jiten    Foram_Jiten          1         0               0.8
9  Edward     Tes     Edward_Tes          1         0               0.8
3   Caleb  Edward   Caleb_Edward          1         0               0.8
7  Isabel     Tes     Isabel_Tes          1         0               1.0
1   Caleb  Isabel   Caleb_Isabel          1         0               0.8
4  Airuna Jasmine Airuna_Jasmine          1         0               1.0
10 Airuna   Foram   Airuna_Foram          1         0               1.0
6  Isabel Jasmine Isabel_Jasmine          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
8                0.2               0.1474115
5                0.2               0.1907604
9                0.8               0.6222160
3                0.8               0.6678453
7                0.8               0.7786557
1                1.0               0.7893406
4                0.8               0.8057359
10               0.8               0.8101005
6                0.8               0.8243425
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.812948887256237 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 9"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1     X2     X1      X2
1     Tes  Sudha  Sudha     Tes
2  Edward    Tes Edward     Tes
3  Edward Airuna Airuna  Edward
4   Chris  Jiten  Chris   Jiten
5   Sudha  Foram  Foram   Sudha
6  Isabel  Caleb  Caleb  Isabel
7 Jasmine Isabel Isabel Jasmine
8   Foram Airuna Airuna   Foram
9   Caleb Airuna Airuna   Caleb
[1] "(rpns)ncycles= 99 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
4  Chris   Jiten    Chris_Jiten          1         0               0.2
5  Foram   Sudha    Foram_Sudha          1         0               0.8
2 Edward     Tes     Edward_Tes          1         0               0.8
1  Sudha     Tes      Sudha_Tes          1         0               0.8
6  Caleb  Isabel   Caleb_Isabel          1         0               0.8
3 Airuna  Edward  Airuna_Edward          1         0               1.0
8 Airuna   Foram   Airuna_Foram          1         0               1.0
7 Isabel Jasmine Isabel_Jasmine          1         0               1.0
9 Airuna   Caleb   Airuna_Caleb          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
4               0.2               0.1070922
5               0.8               0.6390082
2               0.8               0.6711027
1               0.8               0.7025750
6               1.0               0.7647711
3               0.8               0.7857741
8               0.8               0.7865452
7               0.8               0.7909867
9               0.8               0.8048909
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 99 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 9"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1   Jiten   Foram   Foram   Jiten
2  Edward Jasmine  Edward Jasmine
3     Tes   Sudha   Sudha     Tes
4   Sudha Jasmine Jasmine   Sudha
5  Isabel   Foram   Foram  Isabel
6  Isabel  Isabel  Isabel  Isabel
7  Airuna  Airuna  Airuna  Airuna
8   Caleb     Tes   Caleb     Tes
9   Caleb   Chris   Caleb   Chris
10 Edward  Airuna  Airuna  Edward
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
7 Airuna Airuna Airuna_Airuna          1         1                 1
6 Isabel Isabel Isabel_Isabel          1         1                 1
  DegreePercentile2 DegreePercentileProduct
7                 1               0.9851059
6                 1               0.9966266
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2            tag tag_counts selfpairs DegreePercentile1
1    Foram   Jiten    Foram_Jiten          1         0               0.8
9    Caleb   Chris    Caleb_Chris          1         0               0.8
2   Edward Jasmine Edward_Jasmine          1         0               0.8
4  Jasmine   Sudha  Jasmine_Sudha          1         0               0.8
3    Sudha     Tes      Sudha_Tes          1         0               0.8
8    Caleb     Tes      Caleb_Tes          1         0               0.8
5    Foram  Isabel   Foram_Isabel          1         0               0.8
10  Airuna  Edward  Airuna_Edward          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
1                0.2               0.1640510
9                0.2               0.1867043
2                0.8               0.6382433
4                0.8               0.6451819
3                0.8               0.6600907
8                0.8               0.6618752
5                1.0               0.7907297
10               0.8               0.8428232
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.806357736655881 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
      X1      X2     X1      X2
1 Isabel   Jiten Isabel   Jiten
2  Caleb Jasmine  Caleb Jasmine
3  Foram     Tes  Foram     Tes
4  Chris Jasmine  Chris Jasmine
5  Sudha  Airuna Airuna   Sudha
6 Edward   Sudha Edward   Sudha
7  Foram   Caleb  Caleb   Foram
8 Isabel  Airuna Airuna  Isabel
9    Tes  Isabel Isabel     Tes
[1] "(rpns)ncycles= 99 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1     id2           tag tag_counts selfpairs DegreePercentile1
4  Chris Jasmine Chris_Jasmine          1         0               0.2
1 Isabel   Jiten  Isabel_Jiten          1         0               1.0
2  Caleb Jasmine Caleb_Jasmine          1         0               0.8
3  Foram     Tes     Foram_Tes          1         0               0.8
6 Edward   Sudha  Edward_Sudha          1         0               0.8
7  Caleb   Foram   Caleb_Foram          1         0               0.8
5 Airuna   Sudha  Airuna_Sudha          1         0               1.0
9 Isabel     Tes    Isabel_Tes          1         0               1.0
8 Airuna  Isabel Airuna_Isabel          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
4               0.8               0.1324091
1               0.2               0.1584549
2               0.8               0.6041302
3               0.8               0.6266991
6               0.8               0.6594997
7               0.8               0.6647304
5               0.8               0.8163839
9               0.8               0.8278059
8               1.0               1.0167277
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 99 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 9"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2      X1      X2
1      Tes   Foram   Foram     Tes
2   Airuna     Tes  Airuna     Tes
3   Isabel  Airuna  Airuna  Isabel
4    Jiten   Chris   Chris   Jiten
5   Isabel  Edward  Edward  Isabel
6  Jasmine  Airuna  Airuna Jasmine
7   Isabel   Sudha  Isabel   Sudha
8   Edward   Caleb   Caleb  Edward
9    Sudha Jasmine Jasmine   Sudha
10   Caleb   Foram   Caleb   Foram
[1] "(rpns)ncycles= 100 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2            tag tag_counts selfpairs DegreePercentile1
4    Chris   Jiten    Chris_Jiten          1         0               0.2
1    Foram     Tes      Foram_Tes          1         0               0.8
10   Caleb   Foram    Caleb_Foram          1         0               0.8
8    Caleb  Edward   Caleb_Edward          1         0               0.8
9  Jasmine   Sudha  Jasmine_Sudha          1         0               0.8
2   Airuna     Tes     Airuna_Tes          1         0               1.0
7   Isabel   Sudha   Isabel_Sudha          1         0               1.0
6   Airuna Jasmine Airuna_Jasmine          1         0               1.0
5   Edward  Isabel  Edward_Isabel          1         0               0.8
3   Airuna  Isabel  Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
4                0.2              0.02299824
1                0.8              0.58842333
10               0.8              0.60764765
8                0.8              0.64306961
9                0.8              0.67938266
2                0.8              0.76710987
7                0.8              0.78736849
6                0.8              0.79665540
5                1.0              0.79873249
3                1.0              0.99880889
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 100 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 10"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2     X1      X2
1    Jiten   Caleb  Caleb   Jiten
2   Edward Jasmine Edward Jasmine
3    Caleb  Airuna Airuna   Caleb
4   Isabel   Foram  Foram  Isabel
5   Isabel  Isabel Isabel  Isabel
6  Jasmine  Airuna Airuna Jasmine
7    Foram  Edward Edward   Foram
8   Airuna   Sudha Airuna   Sudha
9    Chris     Tes  Chris     Tes
10   Sudha     Tes  Sudha     Tes
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
5 Isabel Isabel Isabel_Isabel          1         1                 1
  DegreePercentile2 DegreePercentileProduct
5                 1               0.9929573
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
9   Chris     Tes      Chris_Tes          1         0               0.2
1   Caleb   Jiten    Caleb_Jiten          1         0               0.8
7  Edward   Foram   Edward_Foram          1         0               0.8
2  Edward Jasmine Edward_Jasmine          1         0               0.8
10  Sudha     Tes      Sudha_Tes          1         0               0.8
3  Airuna   Caleb   Airuna_Caleb          1         0               1.0
4   Foram  Isabel   Foram_Isabel          1         0               0.8
8  Airuna   Sudha   Airuna_Sudha          1         0               1.0
6  Airuna Jasmine Airuna_Jasmine          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
9                0.8               0.1295611
1                0.2               0.1682313
7                0.8               0.6329355
2                0.8               0.6434007
10               0.8               0.6447385
3                0.8               0.7754905
4                1.0               0.8021965
8                0.8               0.8062629
6                0.8               0.8329258
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.811595468071169 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 9"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
      X1      X2     X1      X2
1  Sudha  Airuna Airuna   Sudha
2 Isabel  Isabel Isabel  Isabel
3 Isabel     Tes Isabel     Tes
4  Foram     Tes  Foram     Tes
5  Caleb  Airuna Airuna   Caleb
6 Edward Jasmine Edward Jasmine
7 Edward   Jiten Edward   Jiten
8  Foram   Caleb  Caleb   Foram
9  Chris   Sudha  Chris   Sudha
[1] "(rpns)ncycles= 99 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
2 Isabel Isabel Isabel_Isabel          1         1                 1
  DegreePercentile2 DegreePercentileProduct
2                 1               0.9899074
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
7 Edward   Jiten   Edward_Jiten          1         0               0.8
9  Chris   Sudha    Chris_Sudha          1         0               0.2
4  Foram     Tes      Foram_Tes          1         0               0.8
6 Edward Jasmine Edward_Jasmine          1         0               0.8
8  Caleb   Foram    Caleb_Foram          1         0               0.8
3 Isabel     Tes     Isabel_Tes          1         0               1.0
5 Airuna   Caleb   Airuna_Caleb          1         0               1.0
1 Airuna   Sudha   Airuna_Sudha          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
7               0.2               0.1589629
9               0.8               0.1663184
4               0.8               0.5972960
6               0.8               0.6029509
8               0.8               0.6346683
3               0.8               0.7748497
5               0.8               0.8064384
1               0.8               0.8120868
[1] "================="
[1] "(rpns) ncycles= 99 , degreeProduct.cutoff= 0.808132944086509 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 98 , preserve_rate= 0.1 , length(inpairs[,1])= 8 **

[1] "===Before:Aftersort  ===="
       X1     X2     X1      X2
1   Caleb Isabel  Caleb  Isabel
2   Caleb Isabel  Caleb  Isabel
3 Jasmine  Foram  Foram Jasmine
4   Chris    Tes  Chris     Tes
5     Tes Edward Edward     Tes
6   Foram  Sudha  Foram   Sudha
7   Jiten Airuna Airuna   Jiten
8  Edward Isabel Edward  Isabel
[1] "(rpns)ncycles= 98 ===redopairs===="
    id1    id2          tag tag_counts selfpairs DegreePercentile1
1 Caleb Isabel Caleb_Isabel          2         0               0.8
2 Caleb Isabel Caleb_Isabel          2         0               0.8
  DegreePercentile2 DegreePercentileProduct
1                 1               0.8192508
2                 1               0.8356153
[1] "(rpns)ncycles= 98 ===restpairs===="
     id1     id2           tag tag_counts selfpairs DegreePercentile1
4  Chris     Tes     Chris_Tes          1         0               0.2
7 Airuna   Jiten  Airuna_Jiten          1         0               1.0
5 Edward     Tes    Edward_Tes          1         0               0.8
6  Foram   Sudha   Foram_Sudha          1         0               0.8
3  Foram Jasmine Foram_Jasmine          1         0               0.8
8 Edward  Isabel Edward_Isabel          1         0               0.8
  DegreePercentile2 DegreePercentileProduct
4               0.8               0.1550407
7               0.2               0.1912660
5               0.8               0.6617075
6               0.8               0.6708688
3               0.8               0.6718920
8               1.0               0.7593769
[1] "================="
[1] "(rpns) ncycles= 98 , degreeProduct.cutoff= 0.715634434276838 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 6"

** (rpns) Start ncycles= 97 , preserve_rate= 0.1 , length(inpairs[,1])= 7 **

[1] "===Before:Aftersort  ===="
      X1      X2     X1      X2
1 Isabel  Isabel Isabel  Isabel
2 Edward     Tes Edward     Tes
3 Airuna   Caleb Airuna   Caleb
4  Caleb Jasmine  Caleb Jasmine
5  Chris     Tes  Chris     Tes
6  Jiten   Sudha  Jiten   Sudha
7  Foram   Foram  Foram   Foram
[1] "(rpns)ncycles= 97 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
7  Foram  Foram   Foram_Foram          1         1               0.8
1 Isabel Isabel Isabel_Isabel          1         1               1.0
  DegreePercentile2 DegreePercentileProduct
7               0.8               0.6208641
1               1.0               1.0003976
[1] "(rpns)ncycles= 97 ===restpairs===="
     id1     id2           tag tag_counts selfpairs DegreePercentile1
5  Chris     Tes     Chris_Tes          1         0               0.2
6  Jiten   Sudha   Jiten_Sudha          1         0               0.2
2 Edward     Tes    Edward_Tes          1         0               0.8
4  Caleb Jasmine Caleb_Jasmine          1         0               0.8
3 Airuna   Caleb  Airuna_Caleb          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
5               0.8               0.1420462
6               0.8               0.1667628
2               0.8               0.6259114
4               0.8               0.6596255
3               0.8               0.8445411
[1] "================="
[1] "(rpns) ncycles= 97 , degreeProduct.cutoff= 0.770574897063157 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 5"

** (rpns) Start ncycles= 96 , preserve_rate= 0.1 , length(inpairs[,1])= 6 **

[1] "===Before:Aftersort  ===="
      X1      X2     X1      X2
1  Sudha   Jiten  Jiten   Sudha
2 Edward   Chris  Chris  Edward
3  Caleb   Foram  Caleb   Foram
4 Isabel Jasmine Isabel Jasmine
5 Isabel   Foram  Foram  Isabel
6    Tes     Tes    Tes     Tes
[1] "(rpns)ncycles= 96 ===redopairs===="
  id1 id2     tag tag_counts selfpairs DegreePercentile1 DegreePercentile2
6 Tes Tes Tes_Tes          1         1               0.8               0.8
  DegreePercentileProduct
6               0.6437274
[1] "(rpns)ncycles= 96 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
1  Jiten   Sudha    Jiten_Sudha          1         0               0.2
2  Chris  Edward   Chris_Edward          1         0               0.2
3  Caleb   Foram    Caleb_Foram          1         0               0.8
5  Foram  Isabel   Foram_Isabel          1         0               0.8
4 Isabel Jasmine Isabel_Jasmine          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
1               0.8               0.1153540
2               0.8               0.1539436
3               0.8               0.6380475
5               1.0               0.7856765
4               0.8               0.7987882
[1] "================="
[1] "(rpns) ncycles= 96 , degreeProduct.cutoff= 0.793543503177108 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 5"

** (rpns) Start ncycles= 95 , preserve_rate= 0.1 , length(inpairs[,1])= 5 **

[1] "===Before:Aftersort  ===="
      X1    X2     X1     X2
1    Tes Jiten  Jiten    Tes
2 Isabel Chris  Chris Isabel
3    Tes Sudha  Sudha    Tes
4 Edward Foram Edward  Foram
5  Caleb Foram  Caleb  Foram
[1] "(rpns)ncycles= 95 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 95 ===restpairs===="
     id1    id2          tag tag_counts selfpairs DegreePercentile1
1  Jiten    Tes    Jiten_Tes          1         0               0.2
2  Chris Isabel Chris_Isabel          1         0               0.2
3  Sudha    Tes    Sudha_Tes          1         0               0.8
4 Edward  Foram Edward_Foram          1         0               0.8
5  Caleb  Foram  Caleb_Foram          1         0               0.8
  DegreePercentile2 DegreePercentileProduct
1               0.8               0.1754590
2               1.0               0.2173783
3               0.8               0.6036540
4               0.8               0.6337555
5               0.8               0.6506813
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 95 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 5"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2     X1      X2
1   Isabel  Edward Edward  Isabel
2   Airuna  Airuna Airuna  Airuna
3    Caleb   Chris  Caleb   Chris
4  Jasmine   Caleb  Caleb Jasmine
5    Jiten     Tes  Jiten     Tes
6   Isabel  Airuna Airuna  Isabel
7    Sudha     Tes  Sudha     Tes
8   Edward Jasmine Edward Jasmine
9   Isabel   Foram  Foram  Isabel
10   Foram   Sudha  Foram   Sudha
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
2 Airuna Airuna Airuna_Airuna          1         1                 1
  DegreePercentile2 DegreePercentileProduct
2                 1                1.049633
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
5   Jiten     Tes      Jiten_Tes          1         0               0.2
3   Caleb   Chris    Caleb_Chris          1         0               0.8
8  Edward Jasmine Edward_Jasmine          1         0               0.8
10  Foram   Sudha    Foram_Sudha          1         0               0.8
4   Caleb Jasmine  Caleb_Jasmine          1         0               0.8
7   Sudha     Tes      Sudha_Tes          1         0               0.8
1  Edward  Isabel  Edward_Isabel          1         0               0.8
9   Foram  Isabel   Foram_Isabel          1         0               0.8
6  Airuna  Isabel  Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
5                0.8               0.1656072
3                0.2               0.1892744
8                0.8               0.6058096
10               0.8               0.6269828
4                0.8               0.6551620
7                0.8               0.6764677
1                1.0               0.7748797
9                1.0               0.8047264
6                1.0               0.9621956
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.836220268677303 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 9"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
      X1      X2     X1      X2
1 Isabel   Sudha Isabel   Sudha
2  Caleb   Foram  Caleb   Foram
3 Edward Jasmine Edward Jasmine
4    Tes     Tes    Tes     Tes
5  Foram Jasmine  Foram Jasmine
6  Jiten   Caleb  Caleb   Jiten
7 Edward   Chris  Chris  Edward
8 Airuna  Isabel Airuna  Isabel
9 Airuna   Sudha Airuna   Sudha
[1] "(rpns)ncycles= 99 ===redopairs===="
  id1 id2     tag tag_counts selfpairs DegreePercentile1 DegreePercentile2
4 Tes Tes Tes_Tes          1         1               0.8               0.8
  DegreePercentileProduct
4               0.6620882
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
7  Chris  Edward   Chris_Edward          1         0               0.2
6  Caleb   Jiten    Caleb_Jiten          1         0               0.8
5  Foram Jasmine  Foram_Jasmine          1         0               0.8
3 Edward Jasmine Edward_Jasmine          1         0               0.8
2  Caleb   Foram    Caleb_Foram          1         0               0.8
9 Airuna   Sudha   Airuna_Sudha          1         0               1.0
1 Isabel   Sudha   Isabel_Sudha          1         0               1.0
8 Airuna  Isabel  Airuna_Isabel          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
7               0.8               0.1327362
6               0.2               0.1414576
5               0.8               0.6577668
3               0.8               0.6627754
2               0.8               0.6659588
9               0.8               0.8018582
1               0.8               0.8081365
8               1.0               1.0021496
[1] "================="
[1] "(rpns) ncycles= 99 , degreeProduct.cutoff= 0.86634044583952 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 98 , preserve_rate= 0.1 , length(inpairs[,1])= 8 **

[1] "===Before:Aftersort  ===="
       X1     X2      X1      X2
1   Caleb  Foram   Caleb   Foram
2 Jasmine Edward  Edward Jasmine
3     Tes Airuna  Airuna     Tes
4   Sudha  Chris   Chris   Sudha
5   Caleb  Sudha   Caleb   Sudha
6   Jiten Isabel  Isabel   Jiten
7   Foram Edward  Edward   Foram
8 Jasmine    Tes Jasmine     Tes
[1] "(rpns)ncycles= 98 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 98 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
4   Chris   Sudha    Chris_Sudha          1         0               0.2
6  Isabel   Jiten   Isabel_Jiten          1         0               1.0
2  Edward Jasmine Edward_Jasmine          1         0               0.8
7  Edward   Foram   Edward_Foram          1         0               0.8
5   Caleb   Sudha    Caleb_Sudha          1         0               0.8
1   Caleb   Foram    Caleb_Foram          1         0               0.8
8 Jasmine     Tes    Jasmine_Tes          1         0               0.8
3  Airuna     Tes     Airuna_Tes          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
4               0.8               0.1748827
6               0.2               0.1929623
2               0.8               0.6074528
7               0.8               0.6135627
5               0.8               0.6376048
1               0.8               0.6436515
8               0.8               0.6596154
3               0.8               0.8139370
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 98 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 8"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1     X2     X1      X2
1    Foram Isabel  Foram  Isabel
2   Edward Edward Edward  Edward
3    Caleb  Jiten  Caleb   Jiten
4   Airuna    Tes Airuna     Tes
5  Jasmine  Foram  Foram Jasmine
6    Chris    Tes  Chris     Tes
7  Jasmine Airuna Airuna Jasmine
8   Isabel  Sudha Isabel   Sudha
9    Sudha Airuna Airuna   Sudha
10   Caleb Isabel  Caleb  Isabel
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
2 Edward Edward Edward_Edward          1         1               0.8
  DegreePercentile2 DegreePercentileProduct
2               0.8               0.6289128
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
6   Chris     Tes      Chris_Tes          1         0               0.2
3   Caleb   Jiten    Caleb_Jiten          1         0               0.8
5   Foram Jasmine  Foram_Jasmine          1         0               0.8
9  Airuna   Sudha   Airuna_Sudha          1         0               1.0
4  Airuna     Tes     Airuna_Tes          1         0               1.0
1   Foram  Isabel   Foram_Isabel          1         0               0.8
8  Isabel   Sudha   Isabel_Sudha          1         0               1.0
7  Airuna Jasmine Airuna_Jasmine          1         0               1.0
10  Caleb  Isabel   Caleb_Isabel          1         0               0.8
   DegreePercentile2 DegreePercentileProduct
6                0.8               0.1617894
3                0.2               0.1849199
5                0.8               0.6115318
9                0.8               0.7534756
4                0.8               0.7771970
1                1.0               0.8144847
8                0.8               0.8157649
7                0.8               0.8214405
10               1.0               0.8266389
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.822480210328146 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 9"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
      X1      X2      X1      X2
1    Tes  Edward  Edward     Tes
2 Airuna Jasmine  Airuna Jasmine
3  Sudha Jasmine Jasmine   Sudha
4    Tes  Airuna  Airuna     Tes
5  Sudha  Isabel  Isabel   Sudha
6 Edward   Chris   Chris  Edward
7 Isabel   Jiten  Isabel   Jiten
8 Airuna   Foram  Airuna   Foram
9  Caleb   Foram   Caleb   Foram
[1] "(rpns)ncycles= 99 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 99 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
7  Isabel   Jiten   Isabel_Jiten          1         0               1.0
6   Chris  Edward   Chris_Edward          1         0               0.2
3 Jasmine   Sudha  Jasmine_Sudha          1         0               0.8
9   Caleb   Foram    Caleb_Foram          1         0               0.8
1  Edward     Tes     Edward_Tes          1         0               0.8
4  Airuna     Tes     Airuna_Tes          1         0               1.0
5  Isabel   Sudha   Isabel_Sudha          1         0               1.0
8  Airuna   Foram   Airuna_Foram          1         0               1.0
2  Airuna Jasmine Airuna_Jasmine          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
7               0.2               0.1644383
6               0.8               0.1975441
3               0.8               0.6701312
9               0.8               0.6833895
1               0.8               0.6847670
4               0.8               0.7482431
5               0.8               0.7914752
8               0.8               0.8013681
2               0.8               0.8215785
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 99 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 9"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2      X1      X2
1  Jasmine     Tes Jasmine     Tes
2   Airuna     Tes  Airuna     Tes
3   Edward Jasmine  Edward Jasmine
4    Jiten   Foram   Foram   Jiten
5    Sudha   Foram   Foram   Sudha
6   Isabel  Isabel  Isabel  Isabel
7    Sudha  Edward  Edward   Sudha
8    Caleb   Chris   Caleb   Chris
9   Isabel   Caleb   Caleb  Isabel
10  Airuna  Airuna  Airuna  Airuna
[1] "(rpns)ncycles= 100 ===redopairs===="
      id1    id2           tag tag_counts selfpairs DegreePercentile1
6  Isabel Isabel Isabel_Isabel          1         1                 1
10 Airuna Airuna Airuna_Airuna          1         1                 1
   DegreePercentile2 DegreePercentileProduct
6                  1                1.004298
10                 1                1.021125
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
4   Foram   Jiten    Foram_Jiten          1         0               0.8
8   Caleb   Chris    Caleb_Chris          1         0               0.8
7  Edward   Sudha   Edward_Sudha          1         0               0.8
3  Edward Jasmine Edward_Jasmine          1         0               0.8
5   Foram   Sudha    Foram_Sudha          1         0               0.8
1 Jasmine     Tes    Jasmine_Tes          1         0               0.8
9   Caleb  Isabel   Caleb_Isabel          1         0               0.8
2  Airuna     Tes     Airuna_Tes          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
4               0.2               0.1669127
8               0.2               0.2163640
7               0.8               0.6335292
3               0.8               0.6410512
5               0.8               0.6412565
1               0.8               0.6466227
9               1.0               0.7774549
2               0.8               0.7892015
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.78097891596036 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1      X2     X1      X2
1   Chris   Sudha  Chris   Sudha
2 Jasmine  Airuna Airuna Jasmine
3   Foram   Caleb  Caleb   Foram
4     Tes   Caleb  Caleb     Tes
5  Edward  Airuna Airuna  Edward
6  Edward Jasmine Edward Jasmine
7   Foram   Sudha  Foram   Sudha
8   Jiten  Isabel Isabel   Jiten
9  Isabel  Isabel Isabel  Isabel
[1] "(rpns)ncycles= 99 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
9 Isabel Isabel Isabel_Isabel          1         1                 1
  DegreePercentile2 DegreePercentileProduct
9                 1                 1.02587
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
1  Chris   Sudha    Chris_Sudha          1         0               0.2
8 Isabel   Jiten   Isabel_Jiten          1         0               1.0
4  Caleb     Tes      Caleb_Tes          1         0               0.8
7  Foram   Sudha    Foram_Sudha          1         0               0.8
6 Edward Jasmine Edward_Jasmine          1         0               0.8
3  Caleb   Foram    Caleb_Foram          1         0               0.8
2 Airuna Jasmine Airuna_Jasmine          1         0               1.0
5 Airuna  Edward  Airuna_Edward          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
1               0.8               0.1440629
8               0.2               0.2123199
4               0.8               0.6089913
7               0.8               0.6210190
6               0.8               0.6351046
3               0.8               0.6423255
2               0.8               0.7963331
5               0.8               0.8054073
[1] "================="
[1] "(rpns) ncycles= 99 , degreeProduct.cutoff= 0.799055381602769 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 98 , preserve_rate= 0.1 , length(inpairs[,1])= 8 **

[1] "===Before:Aftersort  ===="
       X1      X2     X1      X2
1 Jasmine   Foram  Foram Jasmine
2   Caleb   Caleb  Caleb   Caleb
3   Sudha  Isabel Isabel   Sudha
4   Foram  Isabel  Foram  Isabel
5  Isabel   Jiten Isabel   Jiten
6   Chris  Edward  Chris  Edward
7  Airuna Jasmine Airuna Jasmine
8     Tes   Sudha  Sudha     Tes
[1] "(rpns)ncycles= 98 ===redopairs===="
    id1   id2         tag tag_counts selfpairs DegreePercentile1
2 Caleb Caleb Caleb_Caleb          1         1               0.8
  DegreePercentile2 DegreePercentileProduct
2               0.8               0.6418249
[1] "(rpns)ncycles= 98 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
6  Chris  Edward   Chris_Edward          1         0               0.2
5 Isabel   Jiten   Isabel_Jiten          1         0               1.0
1  Foram Jasmine  Foram_Jasmine          1         0               0.8
8  Sudha     Tes      Sudha_Tes          1         0               0.8
7 Airuna Jasmine Airuna_Jasmine          1         0               1.0
3 Isabel   Sudha   Isabel_Sudha          1         0               1.0
4  Foram  Isabel   Foram_Isabel          1         0               0.8
  DegreePercentile2 DegreePercentileProduct
6               0.8               0.1434319
5               0.2               0.1837153
1               0.8               0.6086067
8               0.8               0.6441072
7               0.8               0.7894930
3               0.8               0.7948685
4               1.0               0.8032541
[1] "================="
[1] "(rpns) ncycles= 98 , degreeProduct.cutoff= 0.798222770051411 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 7"

** (rpns) Start ncycles= 97 , preserve_rate= 0.1 , length(inpairs[,1])= 7 **

[1] "===Before:Aftersort  ===="
      X1      X2      X1      X2
1  Sudha   Foram   Foram   Sudha
2  Caleb Jasmine   Caleb Jasmine
3  Sudha   Caleb   Caleb   Sudha
4 Airuna  Edward  Airuna  Edward
5 Isabel   Chris   Chris  Isabel
6    Tes Jasmine Jasmine     Tes
7  Jiten  Isabel  Isabel   Jiten
[1] "(rpns)ncycles= 97 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 97 ===restpairs===="
      id1     id2           tag tag_counts selfpairs DegreePercentile1
5   Chris  Isabel  Chris_Isabel          1         0               0.2
7  Isabel   Jiten  Isabel_Jiten          1         0               1.0
1   Foram   Sudha   Foram_Sudha          1         0               0.8
2   Caleb Jasmine Caleb_Jasmine          1         0               0.8
6 Jasmine     Tes   Jasmine_Tes          1         0               0.8
3   Caleb   Sudha   Caleb_Sudha          1         0               0.8
4  Airuna  Edward Airuna_Edward          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
5               1.0               0.2067287
7               0.2               0.2259979
1               0.8               0.6006543
2               0.8               0.6026565
6               0.8               0.6448869
3               0.8               0.6499033
4               0.8               0.7966499
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 97 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 7"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1   Caleb   Caleb   Caleb   Caleb
2   Chris  Edward   Chris  Edward
3  Airuna  Airuna  Airuna  Airuna
4  Isabel  Edward  Edward  Isabel
5     Tes   Jiten   Jiten     Tes
6     Tes   Foram   Foram     Tes
7   Foram Jasmine   Foram Jasmine
8   Sudha Jasmine Jasmine   Sudha
9  Isabel  Airuna  Airuna  Isabel
10  Sudha  Isabel  Isabel   Sudha
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
1  Caleb  Caleb   Caleb_Caleb          1         1               0.8
3 Airuna Airuna Airuna_Airuna          1         1               1.0
  DegreePercentile2 DegreePercentileProduct
1               0.8               0.7001851
3               1.0               1.0397300
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2           tag tag_counts selfpairs DegreePercentile1
5    Jiten     Tes     Jiten_Tes          1         0               0.2
2    Chris  Edward  Chris_Edward          1         0               0.2
6    Foram     Tes     Foram_Tes          1         0               0.8
7    Foram Jasmine Foram_Jasmine          1         0               0.8
8  Jasmine   Sudha Jasmine_Sudha          1         0               0.8
10  Isabel   Sudha  Isabel_Sudha          1         0               1.0
4   Edward  Isabel Edward_Isabel          1         0               0.8
9   Airuna  Isabel Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
5                0.8               0.1596055
2                0.8               0.1732666
6                0.8               0.6090210
7                0.8               0.6417769
8                0.8               0.6457962
10               0.8               0.7897707
4                1.0               0.8379177
9                1.0               1.0519489
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.902127086957424 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1     X2     X1      X2
1  Isabel Airuna Airuna  Isabel
2 Jasmine  Caleb  Caleb Jasmine
3   Sudha  Jiten  Jiten   Sudha
4   Foram    Tes  Foram     Tes
5   Chris Airuna Airuna   Chris
6   Foram Isabel  Foram  Isabel
7 Jasmine  Caleb  Caleb Jasmine
8   Sudha    Tes  Sudha     Tes
9  Edward Edward Edward  Edward
[1] "(rpns)ncycles= 99 ===redopairs===="
     id1     id2           tag tag_counts selfpairs DegreePercentile1
9 Edward  Edward Edward_Edward          1         1               0.8
7  Caleb Jasmine Caleb_Jasmine          2         0               0.8
2  Caleb Jasmine Caleb_Jasmine          2         0               0.8
  DegreePercentile2 DegreePercentileProduct
9               0.8               0.6439776
7               0.8               0.6450802
2               0.8               0.7045214
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
3  Jiten  Sudha   Jiten_Sudha          1         0               0.2
5 Airuna  Chris  Airuna_Chris          1         0               1.0
4  Foram    Tes     Foram_Tes          1         0               0.8
8  Sudha    Tes     Sudha_Tes          1         0               0.8
6  Foram Isabel  Foram_Isabel          1         0               0.8
1 Airuna Isabel Airuna_Isabel          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
3               0.8               0.1547842
5               0.2               0.2243057
4               0.8               0.6295072
8               0.8               0.6581254
6               1.0               0.7853174
1               1.0               1.0013265
[1] "================="
[1] "(rpns) ncycles= 99 , degreeProduct.cutoff= 0.893321961627821 , length(redo.tb[,1])= 3 , length(rest.tb[,1])= 6"

** (rpns) Start ncycles= 98 , preserve_rate= 0.1 , length(inpairs[,1])= 8 **

[1] "===Before:Aftersort  ===="
      X1      X2     X1      X2
1 Edward Jasmine Edward Jasmine
2    Tes   Jiten  Jiten     Tes
3  Sudha     Tes  Sudha     Tes
4  Foram   Caleb  Caleb   Foram
5  Caleb   Foram  Caleb   Foram
6 Edward   Chris  Chris  Edward
7 Isabel Jasmine Isabel Jasmine
8 Airuna   Sudha Airuna   Sudha
[1] "(rpns)ncycles= 98 ===redopairs===="
    id1   id2         tag tag_counts selfpairs DegreePercentile1
4 Caleb Foram Caleb_Foram          2         0               0.8
5 Caleb Foram Caleb_Foram          2         0               0.8
  DegreePercentile2 DegreePercentileProduct
4               0.8               0.6680916
5               0.8               0.6743732
[1] "(rpns)ncycles= 98 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
6  Chris  Edward   Chris_Edward          1         0               0.2
2  Jiten     Tes      Jiten_Tes          1         0               0.2
1 Edward Jasmine Edward_Jasmine          1         0               0.8
3  Sudha     Tes      Sudha_Tes          1         0               0.8
8 Airuna   Sudha   Airuna_Sudha          1         0               1.0
7 Isabel Jasmine Isabel_Jasmine          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
6               0.8               0.1273938
2               0.8               0.2053798
1               0.8               0.6139705
3               0.8               0.6509320
8               0.8               0.7836292
7               0.8               0.8019742
[1] "================="
[1] "(rpns) ncycles= 98 , degreeProduct.cutoff= 0.792801688610222 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 6"

** (rpns) Start ncycles= 97 , preserve_rate= 0.1 , length(inpairs[,1])= 7 **

[1] "===Before:Aftersort  ===="
       X1     X2     X1      X2
1   Chris Edward  Chris  Edward
2   Foram    Tes  Foram     Tes
3   Caleb    Tes  Caleb     Tes
4   Caleb Airuna Airuna   Caleb
5 Jasmine  Foram  Foram Jasmine
6   Sudha  Jiten  Jiten   Sudha
7  Edward  Sudha Edward   Sudha
[1] "(rpns)ncycles= 97 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 97 ===restpairs===="
     id1     id2           tag tag_counts selfpairs DegreePercentile1
1  Chris  Edward  Chris_Edward          1         0               0.2
6  Jiten   Sudha   Jiten_Sudha          1         0               0.2
3  Caleb     Tes     Caleb_Tes          1         0               0.8
7 Edward   Sudha  Edward_Sudha          1         0               0.8
2  Foram     Tes     Foram_Tes          1         0               0.8
5  Foram Jasmine Foram_Jasmine          1         0               0.8
4 Airuna   Caleb  Airuna_Caleb          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
1               0.8               0.1749759
6               0.8               0.1986739
3               0.8               0.5909827
7               0.8               0.6256329
2               0.8               0.6632940
5               0.8               0.6856710
4               0.8               0.7472320
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 97 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 7"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2     X1      X2
1    Caleb   Sudha  Caleb   Sudha
2    Chris  Edward  Chris  Edward
3  Jasmine  Airuna Airuna Jasmine
4      Tes  Isabel Isabel     Tes
5    Caleb Jasmine  Caleb Jasmine
6   Airuna  Edward Airuna  Edward
7    Sudha   Foram  Foram   Sudha
8    Jiten   Foram  Foram   Jiten
9   Isabel     Tes Isabel     Tes
10  Airuna  Isabel Airuna  Isabel
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1 id2        tag tag_counts selfpairs DegreePercentile1
4 Isabel Tes Isabel_Tes          2         0                 1
9 Isabel Tes Isabel_Tes          2         0                 1
  DegreePercentile2 DegreePercentileProduct
4               0.8               0.8042106
9               0.8               0.8505399
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
2   Chris  Edward   Chris_Edward          1         0               0.2
8   Foram   Jiten    Foram_Jiten          1         0               0.8
7   Foram   Sudha    Foram_Sudha          1         0               0.8
1   Caleb   Sudha    Caleb_Sudha          1         0               0.8
5   Caleb Jasmine  Caleb_Jasmine          1         0               0.8
6  Airuna  Edward  Airuna_Edward          1         0               1.0
3  Airuna Jasmine Airuna_Jasmine          1         0               1.0
10 Airuna  Isabel  Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
2                0.8               0.1443914
8                0.2               0.1453646
7                0.8               0.6188119
1                0.8               0.6260876
5                0.8               0.6842942
6                0.8               0.7527547
3                0.8               0.8183397
10               1.0               0.9568555
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.859894468113701 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
      X1      X2      X1     X2
1  Sudha Jasmine Jasmine  Sudha
2  Caleb   Sudha   Caleb  Sudha
3 Airuna  Edward  Airuna Edward
4  Jiten  Isabel  Isabel  Jiten
5    Tes Jasmine Jasmine    Tes
6  Chris  Isabel   Chris Isabel
7 Edward   Foram  Edward  Foram
8 Airuna   Caleb  Airuna  Caleb
9    Tes   Foram   Foram    Tes
[1] "(rpns)ncycles= 99 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 99 ===restpairs===="
      id1    id2           tag tag_counts selfpairs DegreePercentile1
6   Chris Isabel  Chris_Isabel          1         0               0.2
4  Isabel  Jiten  Isabel_Jiten          1         0               1.0
7  Edward  Foram  Edward_Foram          1         0               0.8
1 Jasmine  Sudha Jasmine_Sudha          1         0               0.8
2   Caleb  Sudha   Caleb_Sudha          1         0               0.8
5 Jasmine    Tes   Jasmine_Tes          1         0               0.8
9   Foram    Tes     Foram_Tes          1         0               0.8
3  Airuna Edward Airuna_Edward          1         0               1.0
8  Airuna  Caleb  Airuna_Caleb          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
6               1.0               0.1721803
4               0.2               0.1984061
7               0.8               0.6147496
1               0.8               0.6383277
2               0.8               0.6448620
5               0.8               0.6526985
9               0.8               0.6964379
3               0.8               0.7513199
8               0.8               0.8152645
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 99 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 9"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2      X1      X2
1   Airuna     Tes  Airuna     Tes
2   Isabel   Caleb   Caleb  Isabel
3    Foram  Airuna  Airuna   Foram
4    Jiten     Tes   Jiten     Tes
5   Edward Jasmine  Edward Jasmine
6   Isabel  Isabel  Isabel  Isabel
7    Chris   Sudha   Chris   Sudha
8   Airuna   Foram  Airuna   Foram
9   Edward   Caleb   Caleb  Edward
10 Jasmine   Sudha Jasmine   Sudha
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
3 Airuna  Foram  Airuna_Foram          2         0                 1
8 Airuna  Foram  Airuna_Foram          2         0                 1
6 Isabel Isabel Isabel_Isabel          1         1                 1
  DegreePercentile2 DegreePercentileProduct
3               0.8               0.7903495
8               0.8               0.8245850
6               1.0               0.9804248
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2            tag tag_counts selfpairs DegreePercentile1
4    Jiten     Tes      Jiten_Tes          1         0               0.2
7    Chris   Sudha    Chris_Sudha          1         0               0.2
9    Caleb  Edward   Caleb_Edward          1         0               0.8
10 Jasmine   Sudha  Jasmine_Sudha          1         0               0.8
5   Edward Jasmine Edward_Jasmine          1         0               0.8
2    Caleb  Isabel   Caleb_Isabel          1         0               0.8
1   Airuna     Tes     Airuna_Tes          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
4                0.8               0.1008655
7                0.8               0.1504700
9                0.8               0.6268333
10               0.8               0.6441384
5                0.8               0.6448090
2                1.0               0.7837683
1                0.8               0.8347519
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.804161744515477 , length(redo.tb[,1])= 3 , length(rest.tb[,1])= 7"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1      X2     X1      X2
1   Foram     Tes  Foram     Tes
2  Isabel   Sudha Isabel   Sudha
3  Edward   Chris  Chris  Edward
4  Airuna  Edward Airuna  Edward
5 Jasmine   Caleb  Caleb Jasmine
6   Foram Jasmine  Foram Jasmine
7   Jiten   Sudha  Jiten   Sudha
8   Caleb  Airuna Airuna   Caleb
9  Isabel  Isabel Isabel  Isabel
[1] "(rpns)ncycles= 99 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
9 Isabel Isabel Isabel_Isabel          1         1                 1
  DegreePercentile2 DegreePercentileProduct
9                 1               0.9911558
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1     id2           tag tag_counts selfpairs DegreePercentile1
7  Jiten   Sudha   Jiten_Sudha          1         0               0.2
3  Chris  Edward  Chris_Edward          1         0               0.2
1  Foram     Tes     Foram_Tes          1         0               0.8
5  Caleb Jasmine Caleb_Jasmine          1         0               0.8
6  Foram Jasmine Foram_Jasmine          1         0               0.8
2 Isabel   Sudha  Isabel_Sudha          1         0               1.0
4 Airuna  Edward Airuna_Edward          1         0               1.0
8 Airuna   Caleb  Airuna_Caleb          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
7               0.8               0.1420937
3               0.8               0.1682797
1               0.8               0.6404305
5               0.8               0.6462816
6               0.8               0.6505808
2               0.8               0.7858787
4               0.8               0.7887549
8               0.8               0.8169339
[1] "================="
[1] "(rpns) ncycles= 99 , degreeProduct.cutoff= 0.797208647044124 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 98 , preserve_rate= 0.1 , length(inpairs[,1])= 8 **

[1] "===Before:Aftersort  ===="
      X1      X2      X1      X2
1  Sudha Jasmine Jasmine   Sudha
2  Chris  Edward   Chris  Edward
3  Foram   Foram   Foram   Foram
4 Isabel  Airuna  Airuna  Isabel
5    Tes   Sudha   Sudha     Tes
6  Caleb   Jiten   Caleb   Jiten
7 Isabel  Isabel  Isabel  Isabel
8 Edward Jasmine  Edward Jasmine
[1] "(rpns)ncycles= 98 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
3  Foram  Foram   Foram_Foram          1         1               0.8
7 Isabel Isabel Isabel_Isabel          1         1               1.0
  DegreePercentile2 DegreePercentileProduct
3               0.8               0.6169145
7               1.0               0.9658143
[1] "(rpns)ncycles= 98 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
2   Chris  Edward   Chris_Edward          1         0               0.2
6   Caleb   Jiten    Caleb_Jiten          1         0               0.8
1 Jasmine   Sudha  Jasmine_Sudha          1         0               0.8
8  Edward Jasmine Edward_Jasmine          1         0               0.8
5   Sudha     Tes      Sudha_Tes          1         0               0.8
4  Airuna  Isabel  Airuna_Isabel          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
2               0.8               0.1339241
6               0.2               0.1806008
1               0.8               0.6288182
8               0.8               0.6649410
5               0.8               0.6800598
4               1.0               0.9978216
[1] "================="
[1] "(rpns) ncycles= 98 , degreeProduct.cutoff= 0.838940681836308 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 6"

** (rpns) Start ncycles= 97 , preserve_rate= 0.1 , length(inpairs[,1])= 7 **

[1] "===Before:Aftersort  ===="
       X1     X2     X1      X2
1   Jiten  Caleb  Caleb   Jiten
2 Jasmine  Foram  Foram Jasmine
3     Tes Edward Edward     Tes
4 Jasmine  Chris  Chris Jasmine
5   Foram Edward Edward   Foram
6  Isabel  Sudha Isabel   Sudha
7  Isabel  Sudha Isabel   Sudha
[1] "(rpns)ncycles= 97 ===redopairs===="
     id1   id2          tag tag_counts selfpairs DegreePercentile1
7 Isabel Sudha Isabel_Sudha          2         0                 1
6 Isabel Sudha Isabel_Sudha          2         0                 1
  DegreePercentile2 DegreePercentileProduct
7               0.8               0.7490800
6               0.8               0.7786015
[1] "(rpns)ncycles= 97 ===restpairs===="
     id1     id2           tag tag_counts selfpairs DegreePercentile1
4  Chris Jasmine Chris_Jasmine          1         0               0.2
1  Caleb   Jiten   Caleb_Jiten          1         0               0.8
3 Edward     Tes    Edward_Tes          1         0               0.8
5 Edward   Foram  Edward_Foram          1         0               0.8
2  Foram Jasmine Foram_Jasmine          1         0               0.8
  DegreePercentile2 DegreePercentileProduct
4               0.8               0.1453285
1               0.2               0.1678812
3               0.8               0.6194659
5               0.8               0.6199621
2               0.8               0.6334295
[1] "================="
[1] "(rpns) ncycles= 97 , degreeProduct.cutoff= 0.62804255398539 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 5"

** (rpns) Start ncycles= 96 , preserve_rate= 0.1 , length(inpairs[,1])= 6 **

[1] "===Before:Aftersort  ===="
       X1     X2     X1      X2
1 Jasmine  Foram  Foram Jasmine
2   Sudha  Sudha  Sudha   Sudha
3   Caleb Isabel  Caleb  Isabel
4  Edward  Chris  Chris  Edward
5     Tes Edward Edward     Tes
6   Jiten Isabel Isabel   Jiten
[1] "(rpns)ncycles= 96 ===redopairs===="
    id1   id2         tag tag_counts selfpairs DegreePercentile1
2 Sudha Sudha Sudha_Sudha          1         1               0.8
  DegreePercentile2 DegreePercentileProduct
2               0.8               0.6627841
[1] "(rpns)ncycles= 96 ===restpairs===="
     id1     id2           tag tag_counts selfpairs DegreePercentile1
4  Chris  Edward  Chris_Edward          1         0               0.2
6 Isabel   Jiten  Isabel_Jiten          1         0               1.0
1  Foram Jasmine Foram_Jasmine          1         0               0.8
5 Edward     Tes    Edward_Tes          1         0               0.8
3  Caleb  Isabel  Caleb_Isabel          1         0               0.8
  DegreePercentile2 DegreePercentileProduct
4               0.8               0.1454853
6               0.2               0.1766674
1               0.8               0.6073831
5               0.8               0.6419258
3               1.0               0.8118621
[1] "================="
[1] "(rpns) ncycles= 96 , degreeProduct.cutoff= 0.743887541128316 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 5"

** (rpns) Start ncycles= 95 , preserve_rate= 0.1 , length(inpairs[,1])= 5 **

[1] "===Before:Aftersort  ===="
      X1      X2      X1     X2
1  Sudha   Chris   Chris  Sudha
2 Isabel   Foram   Foram Isabel
3  Jiten   Sudha   Jiten  Sudha
4 Edward  Edward  Edward Edward
5    Tes Jasmine Jasmine    Tes
[1] "(rpns)ncycles= 95 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
4 Edward Edward Edward_Edward          1         1               0.8
  DegreePercentile2 DegreePercentileProduct
4               0.8                 0.64319
[1] "(rpns)ncycles= 95 ===restpairs===="
      id1    id2          tag tag_counts selfpairs DegreePercentile1
3   Jiten  Sudha  Jiten_Sudha          1         0               0.2
1   Chris  Sudha  Chris_Sudha          1         0               0.2
5 Jasmine    Tes  Jasmine_Tes          1         0               0.8
2   Foram Isabel Foram_Isabel          1         0               0.8
  DegreePercentile2 DegreePercentileProduct
3               0.8               0.1428680
1               0.8               0.1656780
5               0.8               0.6723564
2               1.0               0.7494163
[1] "================="
[1] "(rpns) ncycles= 95 , degreeProduct.cutoff= 0.72629832216329 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 4"

** (rpns) Start ncycles= 94 , preserve_rate= 0.1 , length(inpairs[,1])= 4 **

[1] "===Before:Aftersort  ===="
      X1      X2      X1    X2
1  Sudha Jasmine Jasmine Sudha
2 Edward     Tes  Edward   Tes
3  Jiten  Edward  Edward Jiten
4  Chris   Sudha   Chris Sudha
[1] "(rpns)ncycles= 94 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 94 ===restpairs===="
      id1   id2           tag tag_counts selfpairs DegreePercentile1
3  Edward Jiten  Edward_Jiten          1         0               0.8
4   Chris Sudha   Chris_Sudha          1         0               0.2
2  Edward   Tes    Edward_Tes          1         0               0.8
1 Jasmine Sudha Jasmine_Sudha          1         0               0.8
  DegreePercentile2 DegreePercentileProduct
3               0.2               0.1537753
4               0.8               0.1624806
2               0.8               0.6129983
1               0.8               0.6332939
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 94 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 4"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2     X1      X2
1   Isabel Jasmine Isabel Jasmine
2    Jiten  Airuna Airuna   Jiten
3      Tes  Airuna Airuna     Tes
4   Isabel  Edward Edward  Isabel
5  Jasmine  Edward Edward Jasmine
6      Tes   Foram  Foram     Tes
7   Airuna   Caleb Airuna   Caleb
8    Foram   Chris  Chris   Foram
9    Sudha  Isabel Isabel   Sudha
10   Sudha   Caleb  Caleb   Sudha
[1] "(rpns)ncycles= 100 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
8   Chris   Foram    Chris_Foram          1         0               0.2
2  Airuna   Jiten   Airuna_Jiten          1         0               1.0
6   Foram     Tes      Foram_Tes          1         0               0.8
10  Caleb   Sudha    Caleb_Sudha          1         0               0.8
5  Edward Jasmine Edward_Jasmine          1         0               0.8
1  Isabel Jasmine Isabel_Jasmine          1         0               1.0
3  Airuna     Tes     Airuna_Tes          1         0               1.0
4  Edward  Isabel  Edward_Isabel          1         0               0.8
9  Isabel   Sudha   Isabel_Sudha          1         0               1.0
7  Airuna   Caleb   Airuna_Caleb          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
8                0.8               0.1650973
2                0.2               0.1994454
6                0.8               0.6517837
10               0.8               0.6518316
5                0.8               0.6542498
1                0.8               0.7788887
3                0.8               0.7939345
4                1.0               0.7957074
9                0.8               0.7958531
7                0.8               0.8215553
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 100 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 10"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1     Tes   Foram   Foram     Tes
2     Tes Jasmine Jasmine     Tes
3   Sudha   Sudha   Sudha   Sudha
4  Isabel   Caleb   Caleb  Isabel
5  Airuna Jasmine  Airuna Jasmine
6   Caleb  Airuna  Airuna   Caleb
7  Edward   Jiten  Edward   Jiten
8   Foram  Edward  Edward   Foram
9   Chris  Isabel   Chris  Isabel
10 Airuna  Isabel  Airuna  Isabel
[1] "(rpns)ncycles= 100 ===redopairs===="
    id1   id2         tag tag_counts selfpairs DegreePercentile1
3 Sudha Sudha Sudha_Sudha          1         1               0.8
  DegreePercentile2 DegreePercentileProduct
3               0.8               0.6924401
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2            tag tag_counts selfpairs DegreePercentile1
7   Edward   Jiten   Edward_Jiten          1         0               0.8
9    Chris  Isabel   Chris_Isabel          1         0               0.2
1    Foram     Tes      Foram_Tes          1         0               0.8
2  Jasmine     Tes    Jasmine_Tes          1         0               0.8
8   Edward   Foram   Edward_Foram          1         0               0.8
5   Airuna Jasmine Airuna_Jasmine          1         0               1.0
4    Caleb  Isabel   Caleb_Isabel          1         0               0.8
6   Airuna   Caleb   Airuna_Caleb          1         0               1.0
10  Airuna  Isabel  Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
7                0.2               0.1070692
9                1.0               0.2234593
1                0.8               0.6336765
2                0.8               0.6586617
8                0.8               0.6690754
5                0.8               0.7868887
4                1.0               0.8037720
6                0.8               0.8242831
10               1.0               1.0391602
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.867258535130357 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 9"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1 Jasmine Jasmine Jasmine Jasmine
2  Airuna   Foram  Airuna   Foram
3  Edward     Tes  Edward     Tes
4   Jiten   Caleb   Caleb   Jiten
5     Tes  Airuna  Airuna     Tes
6   Caleb   Sudha   Caleb   Sudha
7  Isabel   Sudha  Isabel   Sudha
8  Isabel   Chris   Chris  Isabel
9   Foram  Edward  Edward   Foram
[1] "(rpns)ncycles= 99 ===redopairs===="
      id1     id2             tag tag_counts selfpairs DegreePercentile1
1 Jasmine Jasmine Jasmine_Jasmine          1         1               0.8
  DegreePercentile2 DegreePercentileProduct
1               0.8               0.6531022
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1    id2          tag tag_counts selfpairs DegreePercentile1
4  Caleb  Jiten  Caleb_Jiten          1         0               0.8
8  Chris Isabel Chris_Isabel          1         0               0.2
3 Edward    Tes   Edward_Tes          1         0               0.8
6  Caleb  Sudha  Caleb_Sudha          1         0               0.8
9 Edward  Foram Edward_Foram          1         0               0.8
5 Airuna    Tes   Airuna_Tes          1         0               1.0
7 Isabel  Sudha Isabel_Sudha          1         0               1.0
2 Airuna  Foram Airuna_Foram          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
4               0.2               0.1856190
8               1.0               0.1875858
3               0.8               0.5999923
6               0.8               0.6334309
9               0.8               0.6964363
5               0.8               0.7715126
7               0.8               0.7762859
2               0.8               0.8227307
[1] "================="
[1] "(rpns) ncycles= 99 , degreeProduct.cutoff= 0.790219350272093 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 98 , preserve_rate= 0.1 , length(inpairs[,1])= 8 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1  Isabel   Jiten  Isabel   Jiten
2     Tes  Edward  Edward     Tes
3 Jasmine     Tes Jasmine     Tes
4   Foram Jasmine   Foram Jasmine
5   Chris  Airuna  Airuna   Chris
6  Isabel   Caleb   Caleb  Isabel
7   Sudha   Sudha   Sudha   Sudha
8   Caleb  Edward   Caleb  Edward
[1] "(rpns)ncycles= 98 ===redopairs===="
    id1   id2         tag tag_counts selfpairs DegreePercentile1
7 Sudha Sudha Sudha_Sudha          1         1               0.8
  DegreePercentile2 DegreePercentileProduct
7               0.8               0.6527205
[1] "(rpns)ncycles= 98 ===restpairs===="
      id1     id2           tag tag_counts selfpairs DegreePercentile1
5  Airuna   Chris  Airuna_Chris          1         0               1.0
1  Isabel   Jiten  Isabel_Jiten          1         0               1.0
3 Jasmine     Tes   Jasmine_Tes          1         0               0.8
4   Foram Jasmine Foram_Jasmine          1         0               0.8
2  Edward     Tes    Edward_Tes          1         0               0.8
8   Caleb  Edward  Caleb_Edward          1         0               0.8
6   Caleb  Isabel  Caleb_Isabel          1         0               0.8
  DegreePercentile2 DegreePercentileProduct
5               0.2               0.2129138
1               0.2               0.2315781
3               0.8               0.6016685
4               0.8               0.6271762
2               0.8               0.6414539
8               0.8               0.6590150
6               1.0               0.8129443
[1] "================="
[1] "(rpns) ncycles= 98 , degreeProduct.cutoff= 0.720586703161296 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 7"

** (rpns) Start ncycles= 97 , preserve_rate= 0.1 , length(inpairs[,1])= 7 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1  Airuna  Edward  Airuna  Edward
2     Tes  Edward  Edward     Tes
3 Jasmine   Chris   Chris Jasmine
4   Caleb     Tes   Caleb     Tes
5   Jiten  Isabel  Isabel   Jiten
6   Sudha Jasmine Jasmine   Sudha
7   Sudha   Foram   Foram   Sudha
[1] "(rpns)ncycles= 97 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 97 ===restpairs===="
      id1     id2           tag tag_counts selfpairs DegreePercentile1
3   Chris Jasmine Chris_Jasmine          1         0               0.2
5  Isabel   Jiten  Isabel_Jiten          1         0               1.0
4   Caleb     Tes     Caleb_Tes          1         0               0.8
2  Edward     Tes    Edward_Tes          1         0               0.8
6 Jasmine   Sudha Jasmine_Sudha          1         0               0.8
7   Foram   Sudha   Foram_Sudha          1         0               0.8
1  Airuna  Edward Airuna_Edward          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
3               0.8               0.1951436
5               0.2               0.2108272
4               0.8               0.6014092
2               0.8               0.6213498
6               0.8               0.6228948
7               0.8               0.6420520
1               0.8               0.7960425
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 97 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 7"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1  Airuna   Caleb  Airuna   Caleb
2   Sudha Jasmine Jasmine   Sudha
3   Foram Jasmine   Foram Jasmine
4  Isabel   Jiten  Isabel   Jiten
5  Airuna  Edward  Airuna  Edward
6   Foram  Airuna  Airuna   Foram
7  Edward   Chris   Chris  Edward
8     Tes  Isabel  Isabel     Tes
9  Isabel   Caleb   Caleb  Isabel
10    Tes   Sudha   Sudha     Tes
[1] "(rpns)ncycles= 100 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2           tag tag_counts selfpairs DegreePercentile1
7    Chris  Edward  Chris_Edward          1         0               0.2
4   Isabel   Jiten  Isabel_Jiten          1         0               1.0
2  Jasmine   Sudha Jasmine_Sudha          1         0               0.8
3    Foram Jasmine Foram_Jasmine          1         0               0.8
10   Sudha     Tes     Sudha_Tes          1         0               0.8
8   Isabel     Tes    Isabel_Tes          1         0               1.0
1   Airuna   Caleb  Airuna_Caleb          1         0               1.0
6   Airuna   Foram  Airuna_Foram          1         0               1.0
9    Caleb  Isabel  Caleb_Isabel          1         0               0.8
5   Airuna  Edward Airuna_Edward          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
7                0.8               0.1181277
4                0.2               0.1957362
2                0.8               0.6518003
3                0.8               0.6571906
10               0.8               0.6884945
8                0.8               0.7661799
1                0.8               0.8019736
6                0.8               0.8144765
9                1.0               0.8424268
5                0.8               0.8447979
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 100 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 10"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2     X1      X2
1    Caleb  Airuna Airuna   Caleb
2  Jasmine  Airuna Airuna Jasmine
3   Isabel Jasmine Isabel Jasmine
4   Edward     Tes Edward     Tes
5    Jiten   Caleb  Caleb   Jiten
6   Edward  Isabel Edward  Isabel
7   Airuna     Tes Airuna     Tes
8    Foram  Isabel  Foram  Isabel
9    Sudha   Chris  Chris   Sudha
10   Foram   Sudha  Foram   Sudha
[1] "(rpns)ncycles= 100 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
9   Chris   Sudha    Chris_Sudha          1         0               0.2
5   Caleb   Jiten    Caleb_Jiten          1         0               0.8
4  Edward     Tes     Edward_Tes          1         0               0.8
10  Foram   Sudha    Foram_Sudha          1         0               0.8
6  Edward  Isabel  Edward_Isabel          1         0               0.8
8   Foram  Isabel   Foram_Isabel          1         0               0.8
7  Airuna     Tes     Airuna_Tes          1         0               1.0
3  Isabel Jasmine Isabel_Jasmine          1         0               1.0
1  Airuna   Caleb   Airuna_Caleb          1         0               1.0
2  Airuna Jasmine Airuna_Jasmine          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
9                0.8               0.1477806
5                0.2               0.1881712
4                0.8               0.6409799
10               0.8               0.6475106
6                1.0               0.7902815
8                1.0               0.8108001
7                0.8               0.8168358
3                0.8               0.8214010
1                0.8               0.8269841
2                0.8               0.8398893
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 100 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 10"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
       X1      X2     X1      X2
1  Isabel Jasmine Isabel Jasmine
2   Sudha   Chris  Chris   Sudha
3   Caleb   Jiten  Caleb   Jiten
4   Foram  Isabel  Foram  Isabel
5   Foram  Airuna Airuna   Foram
6   Caleb Jasmine  Caleb Jasmine
7     Tes  Isabel Isabel     Tes
8  Airuna  Edward Airuna  Edward
9   Sudha     Tes  Sudha     Tes
10 Edward  Airuna Airuna  Edward
[1] "(rpns)ncycles= 100 ===redopairs===="
      id1    id2           tag tag_counts selfpairs DegreePercentile1
8  Airuna Edward Airuna_Edward          2         0                 1
10 Airuna Edward Airuna_Edward          2         0                 1
   DegreePercentile2 DegreePercentileProduct
8                0.8                0.743387
10               0.8                0.790339
[1] "(rpns)ncycles= 100 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
3  Caleb   Jiten    Caleb_Jiten          1         0               0.8
2  Chris   Sudha    Chris_Sudha          1         0               0.2
9  Sudha     Tes      Sudha_Tes          1         0               0.8
6  Caleb Jasmine  Caleb_Jasmine          1         0               0.8
4  Foram  Isabel   Foram_Isabel          1         0               0.8
5 Airuna   Foram   Airuna_Foram          1         0               1.0
7 Isabel     Tes     Isabel_Tes          1         0               1.0
1 Isabel Jasmine Isabel_Jasmine          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
3               0.2               0.1211422
2               0.8               0.1928626
9               0.8               0.6342640
6               0.8               0.6382096
4               1.0               0.7455655
5               0.8               0.7598730
7               0.8               0.7880705
1               0.8               0.7963406
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.790551525048813 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1     X2     X1      X2
1   Caleb  Foram  Caleb   Foram
2   Sudha    Tes  Sudha     Tes
3  Isabel  Foram  Foram  Isabel
4  Edward Isabel Edward  Isabel
5 Jasmine Airuna Airuna Jasmine
6   Sudha    Tes  Sudha     Tes
7   Jiten  Chris  Chris   Jiten
8  Airuna  Caleb Airuna   Caleb
9  Airuna Edward Airuna  Edward
[1] "(rpns)ncycles= 99 ===redopairs===="
    id1 id2       tag tag_counts selfpairs DegreePercentile1 DegreePercentile2
6 Sudha Tes Sudha_Tes          2         0               0.8               0.8
2 Sudha Tes Sudha_Tes          2         0               0.8               0.8
  DegreePercentileProduct
6               0.6488035
2               0.6696722
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
7  Chris   Jiten    Chris_Jiten          1         0               0.2
1  Caleb   Foram    Caleb_Foram          1         0               0.8
8 Airuna   Caleb   Airuna_Caleb          1         0               1.0
9 Airuna  Edward  Airuna_Edward          1         0               1.0
3  Foram  Isabel   Foram_Isabel          1         0               0.8
4 Edward  Isabel  Edward_Isabel          1         0               0.8
5 Airuna Jasmine Airuna_Jasmine          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
7               0.2              0.04368378
1               0.8              0.62046284
8               0.8              0.78594195
9               0.8              0.79586029
3               1.0              0.79982563
4               1.0              0.84644778
5               0.8              0.84757386
[1] "================="
[1] "(rpns) ncycles= 99 , degreeProduct.cutoff= 0.846898215986226 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 7"

** (rpns) Start ncycles= 98 , preserve_rate= 0.1 , length(inpairs[,1])= 8 **

[1] "===Before:Aftersort  ===="
      X1     X2     X1     X2
1  Jiten    Tes  Jiten    Tes
2 Edward  Chris  Chris Edward
3 Isabel  Sudha Isabel  Sudha
4 Airuna    Tes Airuna    Tes
5 Edward Isabel Edward Isabel
6  Foram Airuna Airuna  Foram
7  Caleb  Sudha  Caleb  Sudha
8  Caleb  Foram  Caleb  Foram
[1] "(rpns)ncycles= 98 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 98 ===restpairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
1  Jiten    Tes     Jiten_Tes          1         0               0.2
2  Chris Edward  Chris_Edward          1         0               0.2
8  Caleb  Foram   Caleb_Foram          1         0               0.8
7  Caleb  Sudha   Caleb_Sudha          1         0               0.8
5 Edward Isabel Edward_Isabel          1         0               0.8
4 Airuna    Tes    Airuna_Tes          1         0               1.0
6 Airuna  Foram  Airuna_Foram          1         0               1.0
3 Isabel  Sudha  Isabel_Sudha          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
1               0.8               0.1320786
2               0.8               0.1595356
8               0.8               0.5929826
7               0.8               0.6294241
5               1.0               0.8069161
4               0.8               0.8199092
6               0.8               0.8370157
3               0.8               0.8397989
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 98 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 8"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
       X1      X2     X1      X2
1  Airuna   Caleb Airuna   Caleb
2   Jiten  Edward Edward   Jiten
3  Edward Jasmine Edward Jasmine
4   Foram  Isabel  Foram  Isabel
5   Caleb Jasmine  Caleb Jasmine
6   Sudha  Isabel Isabel   Sudha
7     Tes     Tes    Tes     Tes
8  Isabel   Sudha Isabel   Sudha
9   Chris  Airuna Airuna   Chris
10 Airuna   Foram Airuna   Foram
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1   id2          tag tag_counts selfpairs DegreePercentile1
7    Tes   Tes      Tes_Tes          1         1               0.8
8 Isabel Sudha Isabel_Sudha          2         0               1.0
6 Isabel Sudha Isabel_Sudha          2         0               1.0
  DegreePercentile2 DegreePercentileProduct
7               0.8               0.6778641
8               0.8               0.7635873
6               0.8               0.8347070
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
2  Edward   Jiten   Edward_Jiten          1         0               0.8
9  Airuna   Chris   Airuna_Chris          1         0               1.0
5   Caleb Jasmine  Caleb_Jasmine          1         0               0.8
3  Edward Jasmine Edward_Jasmine          1         0               0.8
4   Foram  Isabel   Foram_Isabel          1         0               0.8
1  Airuna   Caleb   Airuna_Caleb          1         0               1.0
10 Airuna   Foram   Airuna_Foram          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
2                0.2               0.1621186
9                0.2               0.1887259
5                0.8               0.6224116
3                0.8               0.6684205
4                1.0               0.7992384
1                0.8               0.8002582
10               0.8               0.8228039
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.809276468305865 , length(redo.tb[,1])= 3 , length(rest.tb[,1])= 7"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1      X2     X1      X2
1  Isabel   Sudha Isabel   Sudha
2  Airuna Jasmine Airuna Jasmine
3   Foram   Caleb  Caleb   Foram
4  Airuna  Edward Airuna  Edward
5  Isabel   Caleb  Caleb  Isabel
6   Chris  Isabel  Chris  Isabel
7 Jasmine  Edward Edward Jasmine
8   Sudha     Tes  Sudha     Tes
9   Jiten     Tes  Jiten     Tes
[1] "(rpns)ncycles= 99 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
9  Jiten     Tes      Jiten_Tes          1         0               0.2
6  Chris  Isabel   Chris_Isabel          1         0               0.2
8  Sudha     Tes      Sudha_Tes          1         0               0.8
3  Caleb   Foram    Caleb_Foram          1         0               0.8
7 Edward Jasmine Edward_Jasmine          1         0               0.8
1 Isabel   Sudha   Isabel_Sudha          1         0               1.0
2 Airuna Jasmine Airuna_Jasmine          1         0               1.0
5  Caleb  Isabel   Caleb_Isabel          1         0               0.8
4 Airuna  Edward  Airuna_Edward          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
9               0.8               0.1947106
6               1.0               0.2298205
8               0.8               0.6103241
3               0.8               0.6713963
7               0.8               0.6759633
1               0.8               0.7681704
2               0.8               0.7842983
5               1.0               0.7924776
4               0.8               0.8152626
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 99 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 9"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2      X1      X2
1    Jiten  Isabel  Isabel   Jiten
2    Sudha Jasmine Jasmine   Sudha
3      Tes  Airuna  Airuna     Tes
4   Isabel   Sudha  Isabel   Sudha
5      Tes  Edward  Edward     Tes
6    Chris  Airuna  Airuna   Chris
7    Caleb   Foram   Caleb   Foram
8   Isabel   Foram   Foram  Isabel
9  Jasmine   Caleb   Caleb Jasmine
10  Edward  Airuna  Airuna  Edward
[1] "(rpns)ncycles= 100 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2           tag tag_counts selfpairs DegreePercentile1
1   Isabel   Jiten  Isabel_Jiten          1         0               1.0
6   Airuna   Chris  Airuna_Chris          1         0               1.0
2  Jasmine   Sudha Jasmine_Sudha          1         0               0.8
7    Caleb   Foram   Caleb_Foram          1         0               0.8
5   Edward     Tes    Edward_Tes          1         0               0.8
9    Caleb Jasmine Caleb_Jasmine          1         0               0.8
4   Isabel   Sudha  Isabel_Sudha          1         0               1.0
10  Airuna  Edward Airuna_Edward          1         0               1.0
8    Foram  Isabel  Foram_Isabel          1         0               0.8
3   Airuna     Tes    Airuna_Tes          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
1                0.2               0.2092451
6                0.2               0.2156363
2                0.8               0.5874072
7                0.8               0.6107449
5                0.8               0.6182319
9                0.8               0.6597541
4                0.8               0.7483378
10               0.8               0.7890475
8                1.0               0.8144876
3                0.8               0.8216717
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 100 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 10"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2     X1      X2
1    Sudha   Foram  Foram   Sudha
2    Chris  Isabel  Chris  Isabel
3   Isabel  Edward Edward  Isabel
4   Airuna     Tes Airuna     Tes
5    Foram Jasmine  Foram Jasmine
6    Sudha   Caleb  Caleb   Sudha
7      Tes  Airuna Airuna     Tes
8    Caleb  Isabel  Caleb  Isabel
9  Jasmine  Airuna Airuna Jasmine
10  Edward   Jiten Edward   Jiten
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1 id2        tag tag_counts selfpairs DegreePercentile1
7 Airuna Tes Airuna_Tes          2         0                 1
4 Airuna Tes Airuna_Tes          2         0                 1
  DegreePercentile2 DegreePercentileProduct
7               0.8               0.8383185
4               0.8               0.8592738
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
10 Edward   Jiten   Edward_Jiten          1         0               0.8
2   Chris  Isabel   Chris_Isabel          1         0               0.2
6   Caleb   Sudha    Caleb_Sudha          1         0               0.8
1   Foram   Sudha    Foram_Sudha          1         0               0.8
5   Foram Jasmine  Foram_Jasmine          1         0               0.8
8   Caleb  Isabel   Caleb_Isabel          1         0               0.8
3  Edward  Isabel  Edward_Isabel          1         0               0.8
9  Airuna Jasmine Airuna_Jasmine          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
10               0.2               0.1550138
2                1.0               0.2019404
6                0.8               0.6312640
1                0.8               0.6686848
5                0.8               0.6886361
8                1.0               0.7659288
3                1.0               0.8407601
9                0.8               0.8442477
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.841806376180974 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1     X2     X1      X2
1   Sudha  Caleb  Caleb   Sudha
2  Isabel  Jiten Isabel   Jiten
3  Isabel  Foram  Foram  Isabel
4   Foram Airuna Airuna   Foram
5   Chris  Sudha  Chris   Sudha
6     Tes  Caleb  Caleb     Tes
7  Airuna    Tes Airuna     Tes
8  Edward Edward Edward  Edward
9 Jasmine Isabel Isabel Jasmine
[1] "(rpns)ncycles= 99 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
8 Edward Edward Edward_Edward          1         1               0.8
  DegreePercentile2 DegreePercentileProduct
8               0.8               0.6536847
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
5  Chris   Sudha    Chris_Sudha          1         0               0.2
2 Isabel   Jiten   Isabel_Jiten          1         0               1.0
6  Caleb     Tes      Caleb_Tes          1         0               0.8
1  Caleb   Sudha    Caleb_Sudha          1         0               0.8
4 Airuna   Foram   Airuna_Foram          1         0               1.0
3  Foram  Isabel   Foram_Isabel          1         0               0.8
9 Isabel Jasmine Isabel_Jasmine          1         0               1.0
7 Airuna     Tes     Airuna_Tes          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
5               0.8               0.1542459
2               0.2               0.1812152
6               0.8               0.6274227
1               0.8               0.6521121
4               0.8               0.8003666
3               1.0               0.8110078
9               0.8               0.8125617
7               0.8               0.8468615
[1] "================="
[1] "(rpns) ncycles= 99 , degreeProduct.cutoff= 0.822851668691116 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 98 , preserve_rate= 0.1 , length(inpairs[,1])= 8 **

[1] "===Before:Aftersort  ===="
       X1     X2      X1     X2
1 Jasmine  Sudha Jasmine  Sudha
2   Foram  Caleb   Caleb  Foram
3  Isabel  Caleb   Caleb Isabel
4  Isabel  Foram   Foram Isabel
5  Edward  Jiten  Edward  Jiten
6  Airuna    Tes  Airuna    Tes
7  Edward  Chris   Chris Edward
8   Sudha Isabel  Isabel  Sudha
[1] "(rpns)ncycles= 98 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 98 ===restpairs===="
      id1    id2           tag tag_counts selfpairs DegreePercentile1
7   Chris Edward  Chris_Edward          1         0               0.2
5  Edward  Jiten  Edward_Jiten          1         0               0.8
1 Jasmine  Sudha Jasmine_Sudha          1         0               0.8
2   Caleb  Foram   Caleb_Foram          1         0               0.8
3   Caleb Isabel  Caleb_Isabel          1         0               0.8
4   Foram Isabel  Foram_Isabel          1         0               0.8
6  Airuna    Tes    Airuna_Tes          1         0               1.0
8  Isabel  Sudha  Isabel_Sudha          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
7               0.8               0.1192532
5               0.2               0.1901735
1               0.8               0.6266518
2               0.8               0.6610211
3               1.0               0.7717416
4               1.0               0.7973552
6               0.8               0.7984924
8               0.8               0.8266738
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 98 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 8"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2     X1      X2
1    Foram   Sudha  Foram   Sudha
2      Tes   Foram  Foram     Tes
3   Airuna     Tes Airuna     Tes
4    Sudha   Caleb  Caleb   Sudha
5    Jiten  Edward Edward   Jiten
6    Caleb Jasmine  Caleb Jasmine
7   Edward   Chris  Chris  Edward
8   Airuna  Isabel Airuna  Isabel
9  Jasmine  Airuna Airuna Jasmine
10  Isabel  Isabel Isabel  Isabel
[1] "(rpns)ncycles= 100 ===redopairs===="
      id1    id2           tag tag_counts selfpairs DegreePercentile1
10 Isabel Isabel Isabel_Isabel          1         1                 1
   DegreePercentile2 DegreePercentileProduct
10                 1                1.024418
[1] "(rpns)ncycles= 100 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
5 Edward   Jiten   Edward_Jiten          1         0               0.8
7  Chris  Edward   Chris_Edward          1         0               0.2
2  Foram     Tes      Foram_Tes          1         0               0.8
1  Foram   Sudha    Foram_Sudha          1         0               0.8
6  Caleb Jasmine  Caleb_Jasmine          1         0               0.8
4  Caleb   Sudha    Caleb_Sudha          1         0               0.8
3 Airuna     Tes     Airuna_Tes          1         0               1.0
9 Airuna Jasmine Airuna_Jasmine          1         0               1.0
8 Airuna  Isabel  Airuna_Isabel          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
5               0.2               0.1190885
7               0.8               0.1590185
2               0.8               0.6005014
1               0.8               0.6224156
6               0.8               0.6227366
4               0.8               0.6494127
3               0.8               0.8006881
9               0.8               0.8206351
8               1.0               1.0171630
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.859940697752925 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 9"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1  Isabel  Edward  Edward  Isabel
2   Foram   Sudha   Foram   Sudha
3 Jasmine     Tes Jasmine     Tes
4   Jiten  Airuna  Airuna   Jiten
5  Isabel   Sudha  Isabel   Sudha
6   Foram Jasmine   Foram Jasmine
7   Caleb  Airuna  Airuna   Caleb
8   Caleb     Tes   Caleb     Tes
9  Edward   Chris   Chris  Edward
[1] "(rpns)ncycles= 99 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 99 ===restpairs===="
      id1     id2           tag tag_counts selfpairs DegreePercentile1
9   Chris  Edward  Chris_Edward          1         0               0.2
4  Airuna   Jiten  Airuna_Jiten          1         0               1.0
8   Caleb     Tes     Caleb_Tes          1         0               0.8
3 Jasmine     Tes   Jasmine_Tes          1         0               0.8
2   Foram   Sudha   Foram_Sudha          1         0               0.8
6   Foram Jasmine Foram_Jasmine          1         0               0.8
5  Isabel   Sudha  Isabel_Sudha          1         0               1.0
7  Airuna   Caleb  Airuna_Caleb          1         0               1.0
1  Edward  Isabel Edward_Isabel          1         0               0.8
  DegreePercentile2 DegreePercentileProduct
9               0.8               0.1751523
4               0.2               0.2068644
8               0.8               0.6436006
3               0.8               0.6517975
2               0.8               0.6529065
6               0.8               0.6636061
5               0.8               0.7674238
7               0.8               0.8223684
1               1.0               0.8261372
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 99 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 9"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2      X1      X2
1      Tes  Isabel  Isabel     Tes
2  Jasmine Jasmine Jasmine Jasmine
3    Jiten     Tes   Jiten     Tes
4    Caleb  Airuna  Airuna   Caleb
5    Foram  Airuna  Airuna   Foram
6    Sudha   Foram   Foram   Sudha
7    Caleb  Edward   Caleb  Edward
8   Edward  Isabel  Edward  Isabel
9   Airuna   Sudha  Airuna   Sudha
10   Chris  Isabel   Chris  Isabel
[1] "(rpns)ncycles= 100 ===redopairs===="
      id1     id2             tag tag_counts selfpairs DegreePercentile1
2 Jasmine Jasmine Jasmine_Jasmine          1         1               0.8
  DegreePercentile2 DegreePercentileProduct
2               0.8                0.637562
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1    id2           tag tag_counts selfpairs DegreePercentile1
3   Jiten    Tes     Jiten_Tes          1         0               0.2
10  Chris Isabel  Chris_Isabel          1         0               0.2
6   Foram  Sudha   Foram_Sudha          1         0               0.8
7   Caleb Edward  Caleb_Edward          1         0               0.8
9  Airuna  Sudha  Airuna_Sudha          1         0               1.0
4  Airuna  Caleb  Airuna_Caleb          1         0               1.0
8  Edward Isabel Edward_Isabel          1         0               0.8
1  Isabel    Tes    Isabel_Tes          1         0               1.0
5  Airuna  Foram  Airuna_Foram          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
3                0.8               0.1468476
10               1.0               0.1943543
6                0.8               0.5895314
7                0.8               0.6500597
9                0.8               0.7814537
4                0.8               0.7921007
8                1.0               0.8132159
1                0.8               0.8198169
5                0.8               0.8270807
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.82126969243244 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 9"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1   Jiten   Sudha   Jiten   Sudha
2  Edward   Sudha  Edward   Sudha
3     Tes  Isabel  Isabel     Tes
4   Chris Jasmine   Chris Jasmine
5  Isabel   Caleb   Caleb  Isabel
6 Jasmine     Tes Jasmine     Tes
7  Airuna  Edward  Airuna  Edward
8  Isabel   Foram   Foram  Isabel
9   Caleb  Airuna  Airuna   Caleb
[1] "(rpns)ncycles= 99 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 99 ===restpairs===="
      id1     id2           tag tag_counts selfpairs DegreePercentile1
1   Jiten   Sudha   Jiten_Sudha          1         0               0.2
4   Chris Jasmine Chris_Jasmine          1         0               0.2
6 Jasmine     Tes   Jasmine_Tes          1         0               0.8
2  Edward   Sudha  Edward_Sudha          1         0               0.8
8   Foram  Isabel  Foram_Isabel          1         0               0.8
7  Airuna  Edward Airuna_Edward          1         0               1.0
9  Airuna   Caleb  Airuna_Caleb          1         0               1.0
3  Isabel     Tes    Isabel_Tes          1         0               1.0
5   Caleb  Isabel  Caleb_Isabel          1         0               0.8
  DegreePercentile2 DegreePercentileProduct
1               0.8              0.09561617
4               0.8              0.14829080
6               0.8              0.62580691
2               0.8              0.62980975
8               1.0              0.78756643
7               0.8              0.79804771
9               0.8              0.81681493
3               0.8              0.81975690
5               1.0              0.82592523
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 99 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 9"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1     X2     X1      X2
1   Isabel Edward Edward  Isabel
2      Tes Isabel Isabel     Tes
3    Foram  Sudha  Foram   Sudha
4    Foram  Jiten  Foram   Jiten
5    Sudha Airuna Airuna   Sudha
6  Jasmine Edward Edward Jasmine
7  Jasmine  Chris  Chris Jasmine
8   Airuna Isabel Airuna  Isabel
9    Caleb Airuna Airuna   Caleb
10   Caleb    Tes  Caleb     Tes
[1] "(rpns)ncycles= 100 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
7   Chris Jasmine  Chris_Jasmine          1         0               0.2
4   Foram   Jiten    Foram_Jiten          1         0               0.8
10  Caleb     Tes      Caleb_Tes          1         0               0.8
6  Edward Jasmine Edward_Jasmine          1         0               0.8
3   Foram   Sudha    Foram_Sudha          1         0               0.8
9  Airuna   Caleb   Airuna_Caleb          1         0               1.0
2  Isabel     Tes     Isabel_Tes          1         0               1.0
5  Airuna   Sudha   Airuna_Sudha          1         0               1.0
1  Edward  Isabel  Edward_Isabel          1         0               0.8
8  Airuna  Isabel  Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
7                0.8               0.1419106
4                0.2               0.1433873
10               0.8               0.6084228
6                0.8               0.6289652
3                0.8               0.6334878
9                0.8               0.7446335
2                0.8               0.7850962
5                0.8               0.7949272
1                1.0               0.7964736
8                1.0               1.0017142
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 100 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 10"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1     X2      X1      X2
1    Jiten  Sudha   Jiten   Sudha
2    Chris Airuna  Airuna   Chris
3    Sudha Airuna  Airuna   Sudha
4  Jasmine Edward  Edward Jasmine
5   Isabel  Caleb   Caleb  Isabel
6    Caleb Isabel   Caleb  Isabel
7      Tes  Foram   Foram     Tes
8  Jasmine    Tes Jasmine     Tes
9   Isabel Airuna  Airuna  Isabel
10   Foram Edward  Edward   Foram
[1] "(rpns)ncycles= 100 ===redopairs===="
    id1    id2          tag tag_counts selfpairs DegreePercentile1
5 Caleb Isabel Caleb_Isabel          2         0               0.8
6 Caleb Isabel Caleb_Isabel          2         0               0.8
  DegreePercentile2 DegreePercentileProduct
5                 1               0.7994562
6                 1               0.8231728
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2            tag tag_counts selfpairs DegreePercentile1
1    Jiten   Sudha    Jiten_Sudha          1         0               0.2
2   Airuna   Chris   Airuna_Chris          1         0               1.0
7    Foram     Tes      Foram_Tes          1         0               0.8
4   Edward Jasmine Edward_Jasmine          1         0               0.8
10  Edward   Foram   Edward_Foram          1         0               0.8
8  Jasmine     Tes    Jasmine_Tes          1         0               0.8
3   Airuna   Sudha   Airuna_Sudha          1         0               1.0
9   Airuna  Isabel  Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
1                0.8               0.1199026
2                0.2               0.2258399
7                0.8               0.6200011
4                0.8               0.6236183
10               0.8               0.6401270
8                0.8               0.6801677
3                0.8               0.7847554
9                1.0               1.0121969
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.852987846314312 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1   Sudha Jasmine Jasmine   Sudha
2  Edward   Sudha  Edward   Sudha
3   Caleb  Airuna  Airuna   Caleb
4 Jasmine  Edward  Edward Jasmine
5   Chris   Caleb   Caleb   Chris
6  Isabel   Foram   Foram  Isabel
7     Tes     Tes     Tes     Tes
8  Airuna   Jiten  Airuna   Jiten
9  Isabel   Foram   Foram  Isabel
[1] "(rpns)ncycles= 99 ===redopairs===="
    id1    id2          tag tag_counts selfpairs DegreePercentile1
7   Tes    Tes      Tes_Tes          1         1               0.8
6 Foram Isabel Foram_Isabel          2         0               0.8
9 Foram Isabel Foram_Isabel          2         0               0.8
  DegreePercentile2 DegreePercentileProduct
7               0.8               0.6521101
6               1.0               0.8166882
9               1.0               0.8387146
[1] "(rpns)ncycles= 99 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
5   Caleb   Chris    Caleb_Chris          1         0               0.8
8  Airuna   Jiten   Airuna_Jiten          1         0               1.0
4  Edward Jasmine Edward_Jasmine          1         0               0.8
2  Edward   Sudha   Edward_Sudha          1         0               0.8
1 Jasmine   Sudha  Jasmine_Sudha          1         0               0.8
3  Airuna   Caleb   Airuna_Caleb          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
5               0.2               0.1642724
8               0.2               0.2200341
4               0.8               0.6211943
2               0.8               0.6491907
1               0.8               0.6527381
3               0.8               0.7916439
[1] "================="
[1] "(rpns) ncycles= 99 , degreeProduct.cutoff= 0.722190970634864 , length(redo.tb[,1])= 3 , length(rest.tb[,1])= 6"

** (rpns) Start ncycles= 98 , preserve_rate= 0.1 , length(inpairs[,1])= 8 **

[1] "===Before:Aftersort  ===="
       X1     X2     X1      X2
1   Sudha    Tes  Sudha     Tes
2  Isabel Edward Edward  Isabel
3 Jasmine  Foram  Foram Jasmine
4 Jasmine  Caleb  Caleb Jasmine
5  Airuna  Sudha Airuna   Sudha
6   Foram Isabel  Foram  Isabel
7   Chris Edward  Chris  Edward
8     Tes  Jiten  Jiten     Tes
[1] "(rpns)ncycles= 98 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 98 ===restpairs===="
     id1     id2           tag tag_counts selfpairs DegreePercentile1
8  Jiten     Tes     Jiten_Tes          1         0               0.2
7  Chris  Edward  Chris_Edward          1         0               0.2
1  Sudha     Tes     Sudha_Tes          1         0               0.8
4  Caleb Jasmine Caleb_Jasmine          1         0               0.8
3  Foram Jasmine Foram_Jasmine          1         0               0.8
5 Airuna   Sudha  Airuna_Sudha          1         0               1.0
2 Edward  Isabel Edward_Isabel          1         0               0.8
6  Foram  Isabel  Foram_Isabel          1         0               0.8
  DegreePercentile2 DegreePercentileProduct
8               0.8               0.1829455
7               0.8               0.1879745
1               0.8               0.6104172
4               0.8               0.6252286
3               0.8               0.6331572
5               0.8               0.7773126
2               1.0               0.7833818
6               1.0               0.8111858
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 98 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 8"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2      X1      X2
1    Foram  Airuna  Airuna   Foram
2   Isabel  Edward  Edward  Isabel
3   Edward  Airuna  Airuna  Edward
4    Jiten     Tes   Jiten     Tes
5  Jasmine Jasmine Jasmine Jasmine
6    Foram   Caleb   Caleb   Foram
7    Sudha  Airuna  Airuna   Sudha
8    Chris     Tes   Chris     Tes
9    Caleb  Isabel   Caleb  Isabel
10   Sudha  Isabel  Isabel   Sudha
[1] "(rpns)ncycles= 100 ===redopairs===="
      id1     id2             tag tag_counts selfpairs DegreePercentile1
5 Jasmine Jasmine Jasmine_Jasmine          1         1               0.8
  DegreePercentile2 DegreePercentileProduct
5               0.8               0.6805104
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1    id2           tag tag_counts selfpairs DegreePercentile1
4   Jiten    Tes     Jiten_Tes          1         0               0.2
8   Chris    Tes     Chris_Tes          1         0               0.2
6   Caleb  Foram   Caleb_Foram          1         0               0.8
2  Edward Isabel Edward_Isabel          1         0               0.8
10 Isabel  Sudha  Isabel_Sudha          1         0               1.0
7  Airuna  Sudha  Airuna_Sudha          1         0               1.0
1  Airuna  Foram  Airuna_Foram          1         0               1.0
3  Airuna Edward Airuna_Edward          1         0               1.0
9   Caleb Isabel  Caleb_Isabel          1         0               0.8
   DegreePercentile2 DegreePercentileProduct
4                0.8               0.1507390
8                0.8               0.1670970
6                0.8               0.6471855
2                1.0               0.7926691
10               0.8               0.7942015
7                0.8               0.8050270
1                0.8               0.8060916
3                0.8               0.8122295
9                1.0               0.8484365
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.819470862173582 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 9"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1     X2      X1      X2
1  Isabel Edward  Edward  Isabel
2  Airuna    Tes  Airuna     Tes
3 Jasmine Airuna  Airuna Jasmine
4   Foram  Chris   Chris   Foram
5   Foram  Sudha   Foram   Sudha
6 Jasmine  Sudha Jasmine   Sudha
7     Tes  Caleb   Caleb     Tes
8  Isabel Airuna  Airuna  Isabel
9  Edward  Jiten  Edward   Jiten
[1] "(rpns)ncycles= 99 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 99 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
9  Edward   Jiten   Edward_Jiten          1         0               0.8
4   Chris   Foram    Chris_Foram          1         0               0.2
5   Foram   Sudha    Foram_Sudha          1         0               0.8
7   Caleb     Tes      Caleb_Tes          1         0               0.8
6 Jasmine   Sudha  Jasmine_Sudha          1         0               0.8
3  Airuna Jasmine Airuna_Jasmine          1         0               1.0
1  Edward  Isabel  Edward_Isabel          1         0               0.8
2  Airuna     Tes     Airuna_Tes          1         0               1.0
8  Airuna  Isabel  Airuna_Isabel          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
9               0.2               0.1334397
4               0.8               0.1631517
5               0.8               0.6379713
7               0.8               0.6671700
6               0.8               0.6722530
3               0.8               0.7527420
1               1.0               0.7705941
2               0.8               0.8065580
8               1.0               0.9967773
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 99 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 9"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2      X1      X2
1    Caleb  Edward   Caleb  Edward
2   Isabel   Chris   Chris  Isabel
3    Foram   Foram   Foram   Foram
4    Sudha  Airuna  Airuna   Sudha
5   Edward Jasmine  Edward Jasmine
6   Airuna  Airuna  Airuna  Airuna
7    Caleb     Tes   Caleb     Tes
8      Tes  Isabel  Isabel     Tes
9  Jasmine   Sudha Jasmine   Sudha
10   Jiten  Isabel  Isabel   Jiten
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
3  Foram  Foram   Foram_Foram          1         1               0.8
6 Airuna Airuna Airuna_Airuna          1         1               1.0
  DegreePercentile2 DegreePercentileProduct
3               0.8               0.5989404
6               1.0               1.0322800
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2            tag tag_counts selfpairs DegreePercentile1
10  Isabel   Jiten   Isabel_Jiten          1         0               1.0
2    Chris  Isabel   Chris_Isabel          1         0               0.2
1    Caleb  Edward   Caleb_Edward          1         0               0.8
5   Edward Jasmine Edward_Jasmine          1         0               0.8
9  Jasmine   Sudha  Jasmine_Sudha          1         0               0.8
7    Caleb     Tes      Caleb_Tes          1         0               0.8
8   Isabel     Tes     Isabel_Tes          1         0               1.0
4   Airuna   Sudha   Airuna_Sudha          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
10               0.2               0.1901452
2                1.0               0.2089740
1                0.8               0.6035364
5                0.8               0.6281121
9                0.8               0.6500439
7                0.8               0.6640320
8                0.8               0.7998774
4                0.8               0.8040885
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.801140722174233 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
      X1      X2     X1      X2
1  Foram Jasmine  Foram Jasmine
2    Tes   Jiten  Jiten     Tes
3 Edward   Caleb  Caleb  Edward
4 Edward  Isabel Edward  Isabel
5 Airuna Jasmine Airuna Jasmine
6 Isabel   Sudha Isabel   Sudha
7 Airuna   Chris Airuna   Chris
8    Tes  Isabel Isabel     Tes
9  Foram   Caleb  Caleb   Foram
[1] "(rpns)ncycles= 99 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 99 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
2  Jiten     Tes      Jiten_Tes          1         0               0.2
7 Airuna   Chris   Airuna_Chris          1         0               1.0
1  Foram Jasmine  Foram_Jasmine          1         0               0.8
9  Caleb   Foram    Caleb_Foram          1         0               0.8
3  Caleb  Edward   Caleb_Edward          1         0               0.8
5 Airuna Jasmine Airuna_Jasmine          1         0               1.0
6 Isabel   Sudha   Isabel_Sudha          1         0               1.0
4 Edward  Isabel  Edward_Isabel          1         0               0.8
8 Isabel     Tes     Isabel_Tes          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
2               0.8               0.1151428
7               0.2               0.1927361
1               0.8               0.6365096
9               0.8               0.6444743
3               0.8               0.6691947
5               0.8               0.7834765
6               0.8               0.8047056
4               1.0               0.8105505
8               0.8               0.8121511
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 99 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 9"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2      X1      X2
1      Tes   Caleb   Caleb     Tes
2    Foram   Caleb   Caleb   Foram
3  Jasmine     Tes Jasmine     Tes
4    Sudha  Isabel  Isabel   Sudha
5   Edward  Isabel  Edward  Isabel
6    Chris  Isabel   Chris  Isabel
7   Airuna Jasmine  Airuna Jasmine
8    Sudha  Airuna  Airuna   Sudha
9   Airuna  Edward  Airuna  Edward
10   Foram   Jiten   Foram   Jiten
[1] "(rpns)ncycles= 100 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2            tag tag_counts selfpairs DegreePercentile1
10   Foram   Jiten    Foram_Jiten          1         0               0.8
6    Chris  Isabel   Chris_Isabel          1         0               0.2
3  Jasmine     Tes    Jasmine_Tes          1         0               0.8
1    Caleb     Tes      Caleb_Tes          1         0               0.8
2    Caleb   Foram    Caleb_Foram          1         0               0.8
8   Airuna   Sudha   Airuna_Sudha          1         0               1.0
7   Airuna Jasmine Airuna_Jasmine          1         0               1.0
5   Edward  Isabel  Edward_Isabel          1         0               0.8
9   Airuna  Edward  Airuna_Edward          1         0               1.0
4   Isabel   Sudha   Isabel_Sudha          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
10               0.2               0.1309028
6                1.0               0.1380818
3                0.8               0.6353472
1                0.8               0.6470034
2                0.8               0.6499198
8                0.8               0.7563195
7                0.8               0.7827087
5                1.0               0.8083031
9                0.8               0.8100731
4                0.8               0.8387418
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 100 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 10"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
       X1      X2     X1      X2
1   Foram   Jiten  Foram   Jiten
2  Edward Jasmine Edward Jasmine
3   Caleb Jasmine  Caleb Jasmine
4   Sudha   Chris  Chris   Sudha
5   Sudha  Edward Edward   Sudha
6   Caleb  Airuna Airuna   Caleb
7  Isabel     Tes Isabel     Tes
8  Isabel  Airuna Airuna  Isabel
9  Airuna     Tes Airuna     Tes
10  Foram  Isabel  Foram  Isabel
[1] "(rpns)ncycles= 100 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
4   Chris   Sudha    Chris_Sudha          1         0               0.2
1   Foram   Jiten    Foram_Jiten          1         0               0.8
3   Caleb Jasmine  Caleb_Jasmine          1         0               0.8
5  Edward   Sudha   Edward_Sudha          1         0               0.8
2  Edward Jasmine Edward_Jasmine          1         0               0.8
9  Airuna     Tes     Airuna_Tes          1         0               1.0
7  Isabel     Tes     Isabel_Tes          1         0               1.0
6  Airuna   Caleb   Airuna_Caleb          1         0               1.0
10  Foram  Isabel   Foram_Isabel          1         0               0.8
8  Airuna  Isabel  Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
4                0.8               0.1132092
1                0.2               0.1775661
3                0.8               0.6343478
5                0.8               0.6523907
2                0.8               0.6693882
9                0.8               0.7726025
7                0.8               0.7904920
6                0.8               0.7991866
10               1.0               0.8031009
8                1.0               1.0049775
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 100 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 10"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1      X2     X1      X2
1    Sudha   Jiten  Jiten   Sudha
2   Airuna Jasmine Airuna Jasmine
3   Edward   Foram Edward   Foram
4  Jasmine  Edward Edward Jasmine
5      Tes   Foram  Foram     Tes
6    Caleb  Airuna Airuna   Caleb
7   Isabel   Sudha Isabel   Sudha
8    Chris     Tes  Chris     Tes
9   Isabel   Caleb  Caleb  Isabel
10  Airuna  Isabel Airuna  Isabel
[1] "(rpns)ncycles= 100 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 100 ===restpairs===="
      id1     id2            tag tag_counts selfpairs DegreePercentile1
1   Jiten   Sudha    Jiten_Sudha          1         0               0.2
8   Chris     Tes      Chris_Tes          1         0               0.2
3  Edward   Foram   Edward_Foram          1         0               0.8
5   Foram     Tes      Foram_Tes          1         0               0.8
4  Edward Jasmine Edward_Jasmine          1         0               0.8
6  Airuna   Caleb   Airuna_Caleb          1         0               1.0
7  Isabel   Sudha   Isabel_Sudha          1         0               1.0
9   Caleb  Isabel   Caleb_Isabel          1         0               0.8
2  Airuna Jasmine Airuna_Jasmine          1         0               1.0
10 Airuna  Isabel  Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
1                0.8              0.09843334
8                0.8              0.16426190
3                0.8              0.64640251
5                0.8              0.64740697
4                0.8              0.68426246
6                0.8              0.75483032
7                0.8              0.77296562
9                1.0              0.79147731
2                0.8              0.81590769
10               1.0              1.02604334
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 100 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 10"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
        X1     X2      X1      X2
1   Airuna  Chris  Airuna   Chris
2  Jasmine  Caleb   Caleb Jasmine
3  Jasmine  Jiten Jasmine   Jiten
4   Isabel  Sudha  Isabel   Sudha
5   Isabel Edward  Edward  Isabel
6    Caleb    Tes   Caleb     Tes
7   Airuna  Foram  Airuna   Foram
8   Edward  Foram  Edward   Foram
9   Isabel  Sudha  Isabel   Sudha
10     Tes Airuna  Airuna     Tes
[1] "(rpns)ncycles= 100 ===redopairs===="
     id1   id2          tag tag_counts selfpairs DegreePercentile1
9 Isabel Sudha Isabel_Sudha          2         0                 1
4 Isabel Sudha Isabel_Sudha          2         0                 1
  DegreePercentile2 DegreePercentileProduct
9               0.8               0.7663903
4               0.8               0.8222027
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2           tag tag_counts selfpairs DegreePercentile1
3  Jasmine   Jiten Jasmine_Jiten          1         0               0.8
1   Airuna   Chris  Airuna_Chris          1         0               1.0
6    Caleb     Tes     Caleb_Tes          1         0               0.8
8   Edward   Foram  Edward_Foram          1         0               0.8
2    Caleb Jasmine Caleb_Jasmine          1         0               0.8
5   Edward  Isabel Edward_Isabel          1         0               0.8
7   Airuna   Foram  Airuna_Foram          1         0               1.0
10  Airuna     Tes    Airuna_Tes          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
3                0.2               0.1574936
1                0.2               0.1831410
6                0.8               0.6307793
8                0.8               0.6472892
2                0.8               0.6525073
5                1.0               0.7969172
7                0.8               0.8050294
10               0.8               0.8335294
[1] "================="
[1] "(rpns) ncycles= 100 , degreeProduct.cutoff= 0.813579400237312 , length(redo.tb[,1])= 2 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 99 , preserve_rate= 0.1 , length(inpairs[,1])= 9 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1   Foram  Airuna  Airuna   Foram
2 Jasmine   Caleb   Caleb Jasmine
3   Foram   Caleb   Caleb   Foram
4  Edward  Isabel  Edward  Isabel
5   Chris   Sudha   Chris   Sudha
6     Tes Jasmine Jasmine     Tes
7  Isabel  Isabel  Isabel  Isabel
8   Jiten  Airuna  Airuna   Jiten
9  Edward   Sudha  Edward   Sudha
[1] "(rpns)ncycles= 99 ===redopairs===="
     id1    id2           tag tag_counts selfpairs DegreePercentile1
7 Isabel Isabel Isabel_Isabel          1         1                 1
  DegreePercentile2 DegreePercentileProduct
7                 1                1.036803
[1] "(rpns)ncycles= 99 ===restpairs===="
      id1     id2           tag tag_counts selfpairs DegreePercentile1
5   Chris   Sudha   Chris_Sudha          1         0               0.2
8  Airuna   Jiten  Airuna_Jiten          1         0               1.0
6 Jasmine     Tes   Jasmine_Tes          1         0               0.8
2   Caleb Jasmine Caleb_Jasmine          1         0               0.8
3   Caleb   Foram   Caleb_Foram          1         0               0.8
9  Edward   Sudha  Edward_Sudha          1         0               0.8
4  Edward  Isabel Edward_Isabel          1         0               0.8
1  Airuna   Foram  Airuna_Foram          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
5               0.8               0.1478838
8               0.2               0.1787940
6               0.8               0.6146191
2               0.8               0.6416676
3               0.8               0.6560154
9               0.8               0.6776716
4               1.0               0.7804287
1               0.8               0.8221962
[1] "================="
[1] "(rpns) ncycles= 99 , degreeProduct.cutoff= 0.792958951334465 , length(redo.tb[,1])= 1 , length(rest.tb[,1])= 8"

** (rpns) Start ncycles= 98 , preserve_rate= 0.1 , length(inpairs[,1])= 8 **

[1] "===Before:Aftersort  ===="
      X1      X2     X1      X2
1 Edward  Airuna Airuna  Edward
2 Isabel Jasmine Isabel Jasmine
3  Chris Jasmine  Chris Jasmine
4 Edward   Caleb  Caleb  Edward
5  Sudha   Jiten  Jiten   Sudha
6  Sudha  Isabel Isabel   Sudha
7    Tes  Isabel Isabel     Tes
8  Foram   Caleb  Caleb   Foram
[1] "(rpns)ncycles= 98 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 98 ===restpairs===="
     id1     id2            tag tag_counts selfpairs DegreePercentile1
5  Jiten   Sudha    Jiten_Sudha          1         0               0.2
3  Chris Jasmine  Chris_Jasmine          1         0               0.2
8  Caleb   Foram    Caleb_Foram          1         0               0.8
4  Caleb  Edward   Caleb_Edward          1         0               0.8
6 Isabel   Sudha   Isabel_Sudha          1         0               1.0
1 Airuna  Edward  Airuna_Edward          1         0               1.0
2 Isabel Jasmine Isabel_Jasmine          1         0               1.0
7 Isabel     Tes     Isabel_Tes          1         0               1.0
  DegreePercentile2 DegreePercentileProduct
5               0.8               0.1309958
3               0.8               0.1713761
8               0.8               0.6312640
4               0.8               0.6720796
6               0.8               0.7857127
1               0.8               0.7876582
2               0.8               0.7884261
7               0.8               0.8017312
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 98 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 8"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 

R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # 20180522 revise to deal with highly connected networks
> # 20180523 add gaussian white noises
> 
> rm(list=ls())
> 
> # R -f ms02_driver_20180523.R --args bg.phys.csv bg.3.csv 100 0.025 9 > log.3.txt
> #R -f file --args input_network_csv_filename output_csv_filename in_ncycles noise_weight debug
> 
> options(echo=TRUE) # if you want see commands in output file 
> args <- commandArgs(trailingOnly = TRUE)
> #print(args)
> # trailingOnly=TRUE means that only your arguments are returned, check:
> # print(commandsArgs(trailingOnly=FALSE))
> infile = args[1]
> #infile = "bg.phys.csv"; 
> outfile = args[2]
> in_ncycles = as.integer(args[3])
> in_noise_weight = as.numeric(args[4])
> debug = as.integer(args[5])
> 
> #set.seed(20180523)
> print(paste("infile=[",infile, "]\n"));
[1] "infile=[ seats.csv ]\n"
> 
> f_match_degree = function (inTb, noise.weight = 0.025 ) {
+   inTb$DegreePercentile1 = degree$DegreePercentile[match(inTb$id1, degree$ORF)];
+   inTb$DegreePercentile2 = degree$DegreePercentile[match(inTb$id2, degree$ORF)];
+   inTb$DegreePercentileProduct = inTb$DegreePercentile1 * inTb$DegreePercentile2; 
+   if (noise.weight > 0 ) {
+     inTb$DegreePercentileProduct =
+            inTb$DegreePercentileProduct + rnorm(n=length(inTb[,1]), sd=noise.weight); 
+   }
+   inTb = inTb[order(inTb$DegreePercentileProduct, decreasing = FALSE), ];
+   return (inTb); 
+ }
> 
> f_redo_rest.tb = function ( inTb ) {
+   redo.tb = inTb[ inTb$selfpairs==1 | inTb$tag_counts>1, ]
+   rest.tb = inTb[ inTb$selfpairs==0 & inTb$tag_counts==1, ]
+   return(list("redo.tb"=redo.tb, "rest.tb" = rest.tb))
+ }
> 
> # recursive_permutation_no_selfpairing_v0.01 rpns
> #This function only perform permutation, but does NOT check for correctness of permutation. 
> #Correctness of permutation should be check outside of this function!
> recursive_permutation_no_selfpairing_v0.01 = function( inpairs,  ncycles=5, indebug=0, preserve_rate = 0.1, noise.weight=0.025 ) { 
+     if(indebug>0) {
+       cat(paste( "\n**", '(rpns) Start ncycles=', ncycles, ", preserve_rate=", preserve_rate, 
+                  ", length(inpairs[,1])=",length(inpairs[,1]), "**\n\n" )); 
+     }
+     longids = c(as.character(inpairs[,1]), as.character(inpairs[,2]) )
+     longids = sample(longids)
+     len = length(inpairs[,1])
+     
+     newpairs0 = data.frame( cbind( longids[1:len], longids[(len+1): (2*len)]) )
+     newpairs = t(apply(newpairs0, 1, sort)); #oder id1 and id2
+     newpairs = data.frame(newpairs); 
+     if(indebug > 2) {#check ids ordering results
+       #print(paste("===before sort ===="),NULL); 
+       #print(newpairs0); print(paste("===after sort ===="),NULL); 
+       #print(newpairs);
+       print(paste("===Before:Aftersort  ===="),NULL); 
+       print(cbind( newpairs0, newpairs));
+     }   
+     names(newpairs) = c('id1', 'id2')
+     newpairs$id1 = as.character( newpairs$id1)
+     newpairs$id2 = as.character( newpairs$id2)    
+     
+     newpairs$tag =  paste(newpairs[,1], newpairs[,2], sep="_")
+     counts = table( newpairs$tag )
+     newpairs$tag_counts = counts[newpairs$tag]
+     # if(indebug>8) {    counts;    }
+     newpairs$selfpairs = ifelse( newpairs$id1 == newpairs$id2, 1, 0 )
+     
+     newpairs = f_match_degree(newpairs, noise.weight = noise.weight ); 
+     
+     redo.tb = newpairs[ newpairs$selfpairs==1 | newpairs$tag_counts>1, ]
+     rest.tb = newpairs[ newpairs$selfpairs==0 & newpairs$tag_counts==1, ]
+     
+     if(indebug>8) {
+       print(paste('(rpns)ncycles=', ncycles, "===redopairs===="),NULL); 
+       print (redo.tb);
+       print(paste('(rpns)ncycles=', ncycles, "===restpairs===="),NULL); 
+       print(rest.tb);
+       print(paste("================="),NULL)
+     }
+     
+     if( length(redo.tb[,1])>=1 ) {
+        if ( ( ncycles == 0) | (length(rest.tb[,1]) < 1) ) { 
+         print(paste("ncycles reached zero, ncycles, OR, not enough data in rest.tb for randomization", ncycles) );
+         if (indebug > 8 ) {
+           write.csv(redo.tb, "tmp/redo_tb.csv");
+           write.csv(rest.tb, "tmp/rest_tb.csv");
+         }
+         return( newpairs ); # no more randomization inside of this function
+       } else  {
+         degreeProduct.cutoff = quantile(rest.tb$DegreePercentileProduct, prob = (1 - preserve_rate)); 
+         unchangedpairs = rest.tb[ rest.tb$DegreePercentileProduct >degreeProduct.cutoff, ]
+         selectedpairs = rbind(redo.tb,rest.tb[ rest.tb$DegreePercentileProduct <=degreeProduct.cutoff , ] )   
+         
+         if (indebug > 0) {
+           print(paste('(rpns) ncycles=', ncycles, ", degreeProduct.cutoff=",degreeProduct.cutoff, 
+                       ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                       ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+         }
+         ncycles = ncycles - 1; 
+         return( rbind(unchangedpairs, 
+                       recursive_permutation_no_selfpairing_v0.01(selectedpairs, ncycles,indebug = indebug, preserve_rate = preserve_rate )))#20180522, recursive trap bug
+       }
+     } else if (length(redo.tb[,1])==0) { #20180522
+       if(indebug>0) {
+         print(paste('(rpns) SUCCESS, ncycles=', ncycles, 
+                     ", length(redo.tb[,1])=",length(redo.tb[,1]),
+                     ", length(rest.tb[,1])=",length(rest.tb[,1]) ),NULL); 
+       }      
+       return (newpairs )
+     } 
+ 
+ }#end of function
> 
> 
> success_flag = 0; 
> global_cycles = 5;
> 
> net = read.csv( infile, colClasses = c("character", "character") )
> head(net)
  person1 person2
1   Chris     Tes
2     Tes  Isabel
3  Isabel   Jiten
4  Isabel  Airuna
5  Airuna   Caleb
6  Airuna   Sudha
> 
> longids = c( net[,1], net[,2] );
> degree = sort( table( longids ), decreasing = TRUE ); 
> degree = data.frame(degree)
> names(degree) = c("ORF", "degree"); 
> degree$ORF = as.character( degree$ORF); 
> # Pick highly connected hub nodes, and prioritize their permutations
> # Notes of caution: This means degree-degree profile are not random in permuted networks
> degree$DegreePercentile = 0;
> for ( i in 1:length(degree[,1])) {
+   degree$DegreePercentile[i] = 1 - length(which(degree$degree> degree$degree[i]))/ length(degree[,1]);
+ }
> 
> #while (( success_flag == 0 & global_cycles > 0 ) ){
> #  global_cycles = global_cycles - 1; 
> 
>   perNet0 = recursive_permutation_no_selfpairing_v0.01(net, ncycles = in_ncycles, indebug = debug, noise.weight = in_noise_weight, preserve_rate = 0.1); 

** (rpns) Start ncycles= 100 , preserve_rate= 0.1 , length(inpairs[,1])= 10 **

[1] "===Before:Aftersort  ===="
       X1      X2      X1      X2
1   Foram  Edward  Edward   Foram
2  Isabel  Edward  Edward  Isabel
3     Tes   Sudha   Sudha     Tes
4   Chris   Caleb   Caleb   Chris
5     Tes Jasmine Jasmine     Tes
6  Isabel Jasmine  Isabel Jasmine
7  Isabel  Airuna  Airuna  Isabel
8  Airuna   Jiten  Airuna   Jiten
9   Sudha   Caleb   Caleb   Sudha
10 Airuna   Foram  Airuna   Foram
[1] "(rpns)ncycles= 100 ===redopairs===="
[1] id1                     id2                     tag                    
[4] tag_counts              selfpairs               DegreePercentile1      
[7] DegreePercentile2       DegreePercentileProduct
<0 rows> (or 0-length row.names)
[1] "(rpns)ncycles= 100 ===restpairs===="
       id1     id2            tag tag_counts selfpairs DegreePercentile1
8   Airuna   Jiten   Airuna_Jiten          1         0               1.0
4    Caleb   Chris    Caleb_Chris          1         0               0.8
5  Jasmine     Tes    Jasmine_Tes          1         0               0.8
1   Edward   Foram   Edward_Foram          1         0               0.8
9    Caleb   Sudha    Caleb_Sudha          1         0               0.8
3    Sudha     Tes      Sudha_Tes          1         0               0.8
10  Airuna   Foram   Airuna_Foram          1         0               1.0
6   Isabel Jasmine Isabel_Jasmine          1         0               1.0
2   Edward  Isabel  Edward_Isabel          1         0               0.8
7   Airuna  Isabel  Airuna_Isabel          1         0               1.0
   DegreePercentile2 DegreePercentileProduct
8                0.2               0.1630932
4                0.2               0.1796781
5                0.8               0.6043322
1                0.8               0.6277078
9                0.8               0.6458353
3                0.8               0.6524444
10               0.8               0.7812210
6                0.8               0.7943487
2                1.0               0.8056492
7                1.0               0.9727512
[1] "================="
[1] "(rpns) SUCCESS, ncycles= 100 , length(redo.tb[,1])= 0 , length(rest.tb[,1])= 10"
>   #perNet0$DegreePercentile1 = degree$DegreePercentile[match(perNet0$id1, degree$ORF)];
>   #perNet0$DegreePercentile2 = degree$DegreePercentile[match(perNet0$id2, degree$ORF)];
>   #perNet0$DegreePercentileProduct = perNet0$DegreePercentile1 * perNet0$DegreePercentile2; 
>   # summary( lm( perNet0$tag_counts ~ perNet0$DegreePercentileProduct) );
>   perNet0 = f_match_degree( perNet0 );
>   
>   x = f_redo_rest.tb( perNet0 );
>   redo.PerNet0 = x$redo.tb; 
>   rest.PerNet0 = x$rest.tb;
>   
>   if ( length(redo.PerNet0[,1])==0 ) {
+     write.csv(perNet0, outfile, quote=F, row.names=F)
+   } else {
+     system(paste("touch ", outfile, "_err")); 
+   }
>   
>   
>   #redo.PerNet0b = perNet0[ perNet0$selfpairs==1 | perNet0$tag_counts>1, ]
>   #rest.PerNet0b = perNet0[ perNet0$selfpairs==0 & perNet0$tag_counts==1, ]
> 
>   #if (debug > 0 ) {
>   # quantile(rest.PerNet0$DegreePercentileProduct, prob=c(0.1, 0.5, 0.80, 0.9)); 
>   #}
>   
>   #keep half of the unqiue pairs with higher degrees unchanged
>   #good.perNet =    rest.PerNet0[ rest.PerNet0$DegreePercentileProduct > median(rest.PerNet0$DegreePercentileProduct), ];
>  
>   # add half of the unique pairs back to the mixing pool
>   #perNet0.redo = 
>   #  rest.PerNet0[ rest.PerNet0$DegreePercentileProduct <= median(rest.PerNet0$DegreePercentileProduct), ];
> 
>   #redo.PerNet0b = rbind( redo.PerNet0, perNet0.redo  ); #redo this part
>   #perNet1 = recursive_permutation_no_selfpairing_v0.01(redo.PerNet0b, ncycles = 10, indebug = 2, preserve_rate = 0.5); 
>   #perNet1 = f_match_degree( perNet1 )
>   #y = f_redo_rest.tb( perNet1 );
>   #redo.PerNet1 = y$redo.tb; 
>   #rest.PerNet1 = y$rest.tb;
>   
>   # check permutation to set success_flag
> #}
> 
> 
> 
> 
> 
> 
> 
